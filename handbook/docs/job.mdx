---
id: job
title: 26.1 调度作业
sidebar_label: 26.1 调度作业
---

:::caution 当前文档还未发布

**当前文档还在编写中，只完成了 20%，将在 2022 年 11 月 21 日前完成。**

:::

---

:::warning 4.8.0 以下版本说明

**在 `Furion 4.8.0+` 版本采用 [Sundial](https://gitee.com/dotnetchina/Sundial) 定时任务替换原有的 `TaskScheduler`**，[查看旧文档](/docs/job-old)

:::

:::important 版本说明

以下内容仅限 `Furion 4.8.0 +` 版本使用。

:::

import useBaseUrl from "@docusaurus/useBaseUrl";

## 26.1.1 关于调度作业

调度作业又称定时任务，顾名思义，定时任务就是在特定的时间或符合某种时间规律自动触发并执行任务。

<img src={useBaseUrl("img/scdr.png")} />

## 26.1.2 快速入门

1. 定义作业处理程序 `MyJob`：

```cs showLineNumbers {1,9}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.CompletedTask;
    }
}
```

2. 在 `Startup.cs` 注册 `Schedule` 服务：

```cs showLineNumbers {1,3-4}
services.AddSchedule(options =>
{
    // 注册作业，并配置作业触发器
    options.AddJob<MyJob>(Triggers.Secondly()); // 表示每秒执行
});
```

3. 查看作业执行结果

```bash showLineNumbers {2,4,6,8,10,12}
info: 2022-11-17 16:23:56.0166669 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger1 2022/11/17 16:23:56  * * * * * *
info: 2022-11-17 16:23:57.0125960 +08:00 星期四 L MyJob[0] #17
      job1 job1_trigger1 2022/11/17 16:23:57  * * * * * *
info: 2022-11-17 16:23:58.0120379 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger1 2022/11/17 16:23:58  * * * * * *
info: 2022-11-17 16:23:59.0071986 +08:00 星期四 L MyJob[0] #5
      job1 job1_trigger1 2022/11/17 16:23:59  * * * * * *
info: 2022-11-17 16:24:00.0196813 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger1 2022/11/17 16:24:00  * * * * * *
info: 2022-11-17 16:24:01.0305799 +08:00 星期四 L MyJob[0] #17
      job1 job1_trigger1 2022/11/17 16:24:01  * * * * * *
```

### 26.1.2.1 指定作业 `Id`

默认情况下，不指定作业 `Id` 会自动生成 `job[编号]`。

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>("myjob", Triggers.Secondly());
});
```

查看作业执行结果：

```bash showLineNumbers  {2,4,6,8,10,12}
info: 2022-11-17 16:25:44.0339177 +08:00 星期四 L MyJob[0] #3
      myjob myjob_trigger1 2022/11/17 16:25:44  * * * * * *
info: 2022-11-17 16:25:45.0064838 +08:00 星期四 L MyJob[0] #14
      myjob myjob_trigger1 2022/11/17 16:25:45  * * * * * *
info: 2022-11-17 16:25:46.0186243 +08:00 星期四 L MyJob[0] #15
      myjob myjob_trigger1 2022/11/17 16:25:46  * * * * * *
info: 2022-11-17 16:25:47.0175115 +08:00 星期四 L MyJob[0] #16
      myjob myjob_trigger1 2022/11/17 16:25:47  * * * * * *
info: 2022-11-17 16:25:48.0304982 +08:00 星期四 L MyJob[0] #15
      myjob myjob_trigger1 2022/11/17 16:25:48  * * * * * *
info: 2022-11-17 16:25:49.0070855 +08:00 星期四 L MyJob[0] #16
      myjob myjob_trigger1 2022/11/17 16:25:49  * * * * * *
```

### 26.1.2.2 多个作业触发器

有时候，一个作业支持多种触发时间，比如 `每分钟` 执行一次，每 `5秒` 执行一次，每分钟第 `3/7/8秒` 执行一次。

```cs showLineNumbers {3-5}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(Triggers.Minutely()   // 每分钟开始
     , Triggers.Period(5000)   // 每 5 秒，也可以使用 Triggers.PeriodSeconds(5)
     , Triggers.Cron("3,7,8 * * * * ?", CronStringFormat.WithSeconds));  // 每分钟第 3/7/8 秒
});
```

查看作业执行结果：

```cs showLineNumbers {2,10,14,18,20}
info: 2022-11-17 16:45:40.5258191 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger2 2022/11/17 16:45:40  5000ms
info: 2022-11-17 16:45:45.5281473 +08:00 星期四 L MyJob[0] #3
      job1 job1_trigger2 2022/11/17 16:45:45  5000ms
info: 2022-11-17 16:45:50.5378417 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger2 2022/11/17 16:45:50  5000ms
info: 2022-11-17 16:45:55.5436499 +08:00 星期四 L MyJob[0] #3
      job1 job1_trigger2 2022/11/17 16:45:55  5000ms
info: 2022-11-17 16:46:00.0253985 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger1 2022/11/17 16:46:00  * * * * *
info: 2022-11-17 16:46:00.5494676 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger2 2022/11/17 16:46:00  5000ms
info: 2022-11-17 16:46:03.0238143 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger3 2022/11/17 16:46:03  3,7,8 * * * * ?
info: 2022-11-17 16:46:05.5629293 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger2 2022/11/17 16:46:05  5000ms
info: 2022-11-17 16:46:07.0169836 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger3 2022/11/17 16:46:07  3,7,8 * * * * ?
info: 2022-11-17 16:46:08.0128756 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger3 2022/11/17 16:46:08  3,7,8 * * * * ?
info: 2022-11-17 16:46:10.5731138 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger2 2022/11/17 16:46:10  5000ms
info: 2022-11-17 16:46:15.5841547 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger2 2022/11/17 16:46:15  5000ms
info: 2022-11-17 16:46:20.5866898 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger2 2022/11/17 16:46:20  5000ms
```

### 26.1.2.3 `串行` 执行

默认情况下，作业采用 `并行` 执行方式，也就是不会等待上一次作业执行完成，只要触发时间到了就自动执行，但一些情况下，我们可能希望等待上一次作业完成再执行，如：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(concurrent: false, Triggers.Secondly()); // 串行，每秒执行
});
```

```cs showLineNumbers {12}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.Delay(2000, stoppingToken); // 这里模拟耗时操作，比如耗时2秒
    }
}
```

查看作业执行结果：

```cs showLineNumbers {2,8,14,20}
info: 2022-11-17 16:57:49.0898900 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger1 2022/11/17 16:57:49  * * * * * *
warn: 2022-11-17 16:57:50.0322409 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:50: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
warn: 2022-11-17 16:57:51.0099629 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:51: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
info: 2022-11-17 16:57:52.0192847 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger1 2022/11/17 16:57:52  * * * * * *
warn: 2022-11-17 16:57:53.0159256 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:53: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
warn: 2022-11-17 16:57:54.0101172 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:54: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
info: 2022-11-17 16:57:55.0038536 +08:00 星期四 L MyJob[0] #13
      job1 job1_trigger1 2022/11/17 16:57:55  * * * * * *
warn: 2022-11-17 16:57:56.0158085 +08:00 星期四 L System.Logging.ScheduleService[0] #16
      11/17/2022 16:57:56: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
warn: 2022-11-17 16:57:57.0276842 +08:00 星期四 L System.Logging.ScheduleService[0] #16
      11/17/2022 16:57:57: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
info: 2022-11-17 16:57:58.0100972 +08:00 星期四 L MyJob[0] #13
      job1 job1_trigger1 2022/11/17 16:57:58  * * * * * *
warn: 2022-11-17 16:57:59.0149137 +08:00 星期四 L System.Logging.ScheduleService[0] #13
      11/17/2022 16:57:59: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
```

默认情况下，使用 `串行` 执行但因为耗时导致**触发时间到了但实际未能执行**会默认输出 `warn` 警告日志，如需关闭只需要：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.LogEnabled = false;
    options.AddJob<MyJob>(concurrent: false, Triggers.Secondly()); // 每秒执行
});
```

查看作业执行结果：

```bash showLineNumbers {2,4,6,8,10}
info: 2022-11-17 17:02:28.0559602 +08:00 星期四 L MyJob[0] #5
      job1 job1_trigger1 2022/11/17 17:02:28  * * * * * *
info: 2022-11-17 17:02:31.0183238 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger1 2022/11/17 17:02:31  * * * * * *
info: 2022-11-17 17:02:34.0130555 +08:00 星期四 L MyJob[0] #13
      job1 job1_trigger1 2022/11/17 17:02:34  * * * * * *
info: 2022-11-17 17:02:37.0040306 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger1 2022/11/17 17:02:37  * * * * * *
info: 2022-11-17 17:02:39.0142346 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger1 2022/11/17 17:02:39  * * * * * *
```

### 26.1.2.4 打印作业完整信息

框架提供了四种方式打印作业完整信息。

- **第一种：输出完整的作业 `JSON` 信息：`context.ConvertToJSON()`**

```cs showLineNumbers {11}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation(context.ConvertToJSON());
        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```json showLineNumbers {3,14}
info: 2022-11-17 17:13:41.0480946 +08:00 星期四 L MyJob[0] #5
      {
        "jobDetail": {
        "jobId": "job1",
        "groupName": null,
        "jobType": "MyJob",
        "assemblyName": "ConsoleApp32",
        "description": null,
        "concurrent": false,
        "includeAnnotations": false,
        "properties": "{}",
        "updatedTime": "2022-11-17T17:13:41.0247430+08:00"
      },
        "trigger": {
        "triggerId": "job1_trigger1",
        "jobId": "job1",
        "triggerType": "Furion.Schedule.CronTrigger",
        "assemblyName": "Furion",
        "args": "[\"@secondly\",0]",
        "description": null,
        "status": 2,
        "startTime": null,
        "endTime": null,
        "lastRunTime": "2022-11-17T17:13:41.0000000",
        "nextRunTime": "2022-11-17T17:13:42.0000000",
        "numberOfRuns": 1,
        "maxNumberOfRuns": 0,
        "numberOfErrors": 0,
        "maxNumberOfErrors": 0,
        "numRetries": 0,
        "retryTimeout": 1000,
        "startNow": true,
        "updatedTime": "2022-11-17T17:13:41.0250214+08:00"
      }
      }
```

- **第二种：输出单独的作业 `JSON` 信息：`jobDetail.ConvertToJSON()` 或 `trigger.ConvertToJSON()`**

```cs showLineNumbers {11-12,14-15}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;
        var trigger = context.Trigger;

        _logger.LogInformation(jobDetail.ConvertToJSON());
        _logger.LogInformation(trigger.ConvertToJSON(NamingConventions.UnderScoreCase));    // 支持三种属性名输出规则

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```json showLineNumbers {2-12,14-34}
info: 2022-11-17 17:17:15.0441407 +08:00 星期四 L MyJob[0] #3
      {
        "jobId": "job1",
        "groupName": null,
        "jobType": "MyJob",
        "assemblyName": "ConsoleApp32",
        "description": null,
        "concurrent": false,
        "includeAnnotations": false,
        "properties": "{}",
        "updatedTime": "2022-11-17T17:17:15.0103913+08:00"
      }
info: 2022-11-17 17:17:15.0503546 +08:00 星期四 L MyJob[0] #3
      {
        "trigger_id": "job1_trigger1",
        "job_id": "job1",
        "trigger_type": "Furion.Schedule.CronTrigger",
        "assembly_name": "Furion",
        "args": "[\"@secondly\",0]",
        "description": null,
        "status": 2,
        "start_time": null,
        "end_time": null,
        "last_run_time": "2022-11-17T17:17:15.0000000",
        "next_run_time": "2022-11-17T17:17:16.0000000",
        "number_of_runs": 1,
        "max_number_of_runs": 0,
        "number_of_errors": 0,
        "max_number_of_errors": 0,
        "num_retries": 0,
        "retry_timeout": 1000,
        "start_now": true,
        "updated_time": "2022-11-17T17:17:15.0109612+08:00"
      }
```

- **第三种：输出单独的作业 `SQL` 信息：`jobDetail.ConvertToSQL()` 或 `trigger.ConvertToSQL()`**

```cs showLineNumbers {11-12,14-16}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;
        var trigger = context.Trigger;

        _logger.LogInformation(jobDetail.ConvertToSQL("作业信息表名", PersistenceBehavior.Appended));  // 输出新增语句
        _logger.LogInformation(trigger.ConvertToSQL("作业触发器表名", PersistenceBehavior.Removed, NamingConventions.Pascal));    // 输出删除语句
        _logger.LogInformation(trigger.ConvertToSQL("作业触发器表名", PersistenceBehavior.Updated, NamingConventions.UnderScoreCase));    // 输出更新语句

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```sql showLineNumbers {2,25,27}
info: 2022-11-17 17:35:11.1085426 +08:00 星期四 L MyJob[0] #9
      INSERT INTO 作业信息表名(
      [jobId],
      [groupName],
      [jobType],
      [assemblyName],
      [description],
      [concurrent],
      [includeAnnotations],
      [properties],
      [updatedTime]
      )
      VALUES(
      'job1',
      NULL,
      'MyJob',
      'ConsoleApp32',
      NULL,
      0,
      0,
      '{}',
      '2022/11/17 17:35:11'
      );
info: 2022-11-17 17:35:11.1150444 +08:00 星期四 L MyJob[0] #9
      DELETE FROM 作业触发器表名 WHERE [TriggerId] = 'job1_trigger1' AND [JobId] = 'job1';
info: 2022-11-17 17:35:11.1190961 +08:00 星期四 L MyJob[0] #9
      UPDATE 作业触发器表名
      SET [trigger_id] = 'job1_trigger1',
      [job_id] = 'job1',
      [trigger_type] = 'Furion.Schedule.CronTrigger',
      [assembly_name] = 'Furion',
      [args] = '["@secondly",0]',
      [description] = NULL,
      [status] = 2,
      [start_time] = NULL,
      [end_time] = NULL,
      [last_run_time] = '2022/11/17 17:35:11',
      [next_run_time] = '2022/11/17 17:35:12',
      [number_of_runs] = 1,
      [max_number_of_runs] = 0,
      [number_of_errors] = 0,
      [max_number_of_errors] = 0,
      [num_retries] = 0,
      [retry_timeout] = 1000,
      [start_now] = 1,
      [updated_time] = '2022/11/17 17:35:11'
      WHERE [trigger_id] = 'job1_trigger1' AND [job_id] = 'job1';
```

- **第四种：输出单独的作业 `Monitor` 信息：`jobDetail.ConvertToMonitor()` 或 `trigger.ConvertToMonitor()`**

```cs showLineNumbers {11-12,14-15}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;
        var trigger = context.Trigger;

        _logger.LogInformation(jobDetail.ConvertToMonitor());
        _logger.LogInformation(trigger.ConvertToMonitor());

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```bash showLineNumbers {2,16}
info: 2022-11-17 17:39:09.1086517 +08:00 星期四 L MyJob[0] #3
      ┏━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
      ┣ MyJob
      ┣
      ┣ JobId：                     job1
      ┣ GroupName：
      ┣ JobType：                   MyJob
      ┣ AssemblyName：              ConsoleApp32
      ┣ Description：
      ┣ Concurrent：                False
      ┣ IncludeAnnotations：        False
      ┣ Properties：                {}
      ┣ UpdatedTime：               2022/11/17 17:39:09
      ┗━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
info: 2022-11-17 17:39:09.1133162 +08:00 星期四 L MyJob[0] #3
      ┏━━━━━━━━━━━  Trigger ━━━━━━━━━━━
      ┣ Furion.Schedule.CronTrigger
      ┣
      ┣ TriggerId：                job1_trigger1
      ┣ JobId：                    job1
      ┣ TriggerType：              Furion.Schedule.CronTrigger
      ┣ AssemblyName：             Furion
      ┣ Args：                     ["@secondly",0]
      ┣ Description：
      ┣ Status：                   Running
      ┣ StartTime：
      ┣ EndTime：
      ┣ LastRunTime：              2022/11/17 17:39:09
      ┣ NextRunTime：              2022/11/17 17:39:10
      ┣ NumberOfRuns：             1
      ┣ MaxNumberOfRuns：          0
      ┣ NumberOfErrors：           0
      ┣ MaxNumberOfErrors：        0
      ┣ NumRetries：               0
      ┣ RetryTimeout：             1000
      ┣ StartNow：                 True
      ┣ UpdatedTime：              2022/11/17 17:39:09
      ┗━━━━━━━━━━━  Trigger ━━━━━━━━━━━
```

### 26.1.2.5 运行时（动态）操作作业

有时候，我们需要在运行时对作业动态的增加，更新，删除等操作，如动态添加作业：

1. 注册 `services.AddSchedule()` 服务

```cs showLineNumbers {2,5}
// 可以完全动态操作，只需要注册服务即可
services.AddSchedule();

// 也可以部分静态，部分动态注册
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(concurrent: false, Triggers.PeriodSeconds(5));
});
```

2. 注入 `ISchedulerFactory` 服务

```cs showLineNumbers {4,11}
public class YourService: IYourService
{
    private readonly ISchedulerFactory _schedulerFactory;
    public YourService(ISchedulerFactory schedulerFactory)
    {
        _schedulerFactory = schedulerFactory;
    }

    public void AddJob()
    {
        _schedulerFactory.AddJob<MyJob>("动态作业 Id", Triggers.Secondly());
    }
}
```

3. 查看作业执行结果

```bash showLineNumbers {2,4,6,8,10,20}
warn: 2022-11-17 17:54:35.2654513 +08:00 星期四 L System.Logging.ScheduleService[0] #5
      Schedule Hosted Service cancels hibernation.
info: 2022-11-17 17:54:35.2670018 +08:00 星期四 L System.Logging.ScheduleService[0] #5
      The Scheduler of <动态作业 Id> successfully added to the schedule.
info: 2022-11-17 17:54:36.0834925 +08:00 星期四 L MyJob[0] #5
      job1 job1_trigger1 2022/11/17 17:54:36  5000ms
info: 2022-11-17 17:54:36.0911692 +08:00 星期四 L MyJob[0] #3
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:36  * * * * * *
info: 2022-11-17 17:54:37.0146251 +08:00 星期四 L MyJob[0] #18
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:37  * * * * * *
info: 2022-11-17 17:54:38.0071504 +08:00 星期四 L MyJob[0] #16
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:38  * * * * * *
info: 2022-11-17 17:54:39.0140840 +08:00 星期四 L MyJob[0] #17
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:39  * * * * * *
info: 2022-11-17 17:54:40.0173240 +08:00 星期四 L MyJob[0] #16
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:40  * * * * * *
info: 2022-11-17 17:54:41.0249043 +08:00 星期四 L MyJob[0] #16
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:41  * * * * * *
info: 2022-11-17 17:54:41.0550205 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger1 2022/11/17 17:54:41  5000ms
info: 2022-11-17 17:54:42.0171271 +08:00 星期四 L MyJob[0] #15
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:42  * * * * * *
info: 2022-11-17 17:54:43.0288486 +08:00 星期四 L MyJob[0] #18
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:43  * * * * * *
info: 2022-11-17 17:54:44.0092455 +08:00 星期四 L MyJob[0] #15
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:44  * * * * * *
```

### 26.1.2.7 作业触发器特性

默认情况下，框架不会扫描 `IJob` 实现类的作业触发器特性，但可以设置作业的 `IncludeAnnotations` 进行启用。

1. 启用 `IncludeAnnotations` 扫描

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob(JobBuilder.Create<MyJob>().SetIncludeAnnotations(true)
        , Triggers.PeriodSeconds(5));
});
```

2. 在 `MyJob` 中添加多个作业触发器特性

```cs showLineNumbers {1-2}
[Minutely]
[Cron("3,7,8 * * * * ?", CronStringFormat.WithSeconds)]
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");

        await Task.CompletedTask;
    }
}
```

3. 查看作业执行结果

```bash showLineNumbers {2,4,6,8,10,12,14,16,18}
info: 2022-11-18 10:28:56.3382585 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger1 2022/11/18 10:28:56  5000ms
info: 2022-11-18 10:29:00.0219493 +08:00 星期五 L MyJob[0] #5
      job1 job1_trigger2 2022/11/18 10:29:00  * * * * *
info: 2022-11-18 10:29:01.3318716 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger1 2022/11/18 10:29:01  5000ms
info: 2022-11-18 10:29:03.0127992 +08:00 星期五 L MyJob[0] #16
      job1 job1_trigger3 2022/11/18 10:29:03  3,7,8 * * * * ?
info: 2022-11-18 10:29:06.3457728 +08:00 星期五 L MyJob[0] #16
      job1 job1_trigger1 2022/11/18 10:29:06  5000ms
info: 2022-11-18 10:29:07.0318919 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger3 2022/11/18 10:29:07  3,7,8 * * * * ?
info: 2022-11-18 10:29:08.0141479 +08:00 星期五 L MyJob[0] #8
      job1 job1_trigger3 2022/11/18 10:29:08  3,7,8 * * * * ?
info: 2022-11-18 10:29:11.3468100 +08:00 星期五 L MyJob[0] #16
      job1 job1_trigger1 2022/11/18 10:29:11  5000ms
info: 2022-11-18 10:29:16.3504029 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger1 2022/11/18 10:29:16  5000ms
```

## 26.1.3 作业信息 `JobDetail` 及构建器

### 26.1.3.1 关于作业信息

框架提供了 `JobDetail` 类型来描述作业信息，`JobDetail` 类型提供以下**只读属性**：

| 属性名               | 属性类型    | 默认值  | 说明                                                                 |
| -------------------- | ----------- | ------- | -------------------------------------------------------------------- |
| `JobId`              | `string`    |         | 作业 `Id`                                                            |
| `GroupName`          | `string`    |         | 作业组名称                                                           |
| `JobType`            | `string`    |         | 作业处理程序类型，存储的是类型的 `FullName`                          |
| `AssemblyName`       | `string`    |         | 作业处理程序类型所在程序集，存储的是程序集 `Name`                    |
| `Description`        | `string`    |         | 描述信息                                                             |
| `Concurrent`         | `bool`      | `true`  | 描述信息，如果设置为 `false`，那么使用 `串行` 执行                   |
| `IncludeAnnotations` | `bool`      | `false` | 是否扫描 `IJob` 实现类 `[Trigger]` 特性触发器                        |
| `Properties`         | `string`    | `"{}"`  | 作业信息额外数据，由 `Dictionary<string, object>` 序列化成字符串存储 |
| `UpdatedTime`        | `DateTime?` |         | 作业更新时间                                                         |

### 26.1.3.2 关于作业信息构建器

作业信息 `JobDetail` 是作业调度模块提供运行时的**只读类型**，那么我们该如何创建或变更 `JobDetail` 呢？

`JobBuilder` 是作业调度模块提供可用来生成运行时 `JobDetail` 的类型，这样做的好处可避免外部直接修改运行时 `JobDetail` 数据，还能实现任何修改动作监听，也能避免多线程抢占情况。

作业调度模块提供了多种方式用来创建 `JobBuilder` 对象。

1. **通过 `Create` 静态方法创建**

```cs showLineNumbers {2,5,8}
// 根据 IJob 实现类类型创建
var jobBuilder = JobBuilder.Create<MyJob>();

// 根据 Type 类型创建
var jobBuilder = JobBuilder.Create(typeof(MyJob));

// 根据程序集名称和类型完全限定名（FullName）创建
var jobBuilder = JobBuilder.Create("YourProject", "YourProject.MyJob");
```

2. **通过 `JobDetail` 类型创建**

这种方式常用于在运行时更新作业信息。

```cs showLineNumbers
var jobBuilder = JobBuilder.From(jobDetail);
```

3. **通过 `JSON` 字符串创建**

该方式非常灵活，可从配置文件，`JSON` 字符串，或其他能够返回 `JSON` 字符串的地方创建。

```cs showLineNumbers {2-12}
var jobBuilder = JobBuilder.From(@"
{
    ""jobId"": ""job1"",
    ""groupName"": null,
    ""jobType"": ""Furion.Application.TestJob"",
    ""assemblyName"": ""Furion.Application"",
    ""description"": null,
    ""concurrent"": true,
    ""includeAnnotations"": false,
    ""properties"": ""{}"",
    ""updatedTime"": ""2022-11-17T09:25:47.0471107+08:00""
}");
```

如果使用的是 `.NET7`，可使用 `"""` 避免转义，如：

```cs showLineNumbers {2-12}
var jobBuilder = JobBuilder.From("""
{
    "jobId": "job1",
    "groupName": null,
    "jobType": "Furion.Application.TestJob",
    "assemblyName": "Furion.Application",
    "description": null,
    "concurrent": true,
    "includeAnnotations": false,
    "properties": "{}",
    "updatedTime": "2022-11-17T09:25:47.0471107+08:00"
}""");
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 命名方式。

**不支持 `UnderScoreCase（下划线命名法）`** ，如 `"include_annotations": true`

:::

4. **还可以通过 `Clone` 静态方法从一个 `JobBuilder` 创建**

```cs showLineNumbers
var jobBuilder = JobBuilder.Clone(formJobBuilder);
```

:::important 克隆说明

克隆操作只会克隆 `AssemblyName`，`JobType`，`GroupName`，`Description`，`Concurrent`，`IncludeAnnotations`，`Properties`。

**不会克隆 `JobId`，`UpdatedTime`。**

:::

5. **还可以通过 `LoadFrom` 实例方法填充当前的 `JobBuilder`**

比如可以传递匿名类型，类类型：

```cs showLineNumbers {2,9,14}
// 会覆盖所有相同的值
jobBuilder.LoadFrom(new
{
      Description = "我是描述",
      Concurrent = false
});

// 支持多个填充，还可以配置跳过 null 值覆盖
jobBuilder.LoadFrom(new
{
      Description = "我是另外一个描述",
      Concurrent = false,
      IncludeAnnotations = default(object)      // 会跳过赋值
}, ignoreNullValue: true);
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 和 `UnderScoreCase（下划线命名法）` 命名方式。

:::

## 26.1.4 作业处理程序 `IJob`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.5 作业触发器 `Trigger` 及构建器

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.6 作业计划 `Scheduler` 及构建器

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.7 作业计划工厂 `ISchedulerFactory`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.8 作业监视器 `IJobMonitor`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.9 作业执行器 `IJobExecutor`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.10 作业格式化输出

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.11 作业持久化同步

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.12 作业集群控制

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.13 作业如何部署

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.14 常见问题

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.15 反馈与建议

:::note 与我们交流

给 Furion 提 [Issue](https://gitee.com/dotnetchina/Furion/issues/new?issue)。

:::
