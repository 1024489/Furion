---
id: job
title: 26.1 调度作业
sidebar_label: 26.1 调度作业
---

import Tag from "@site/src/components/Tag.js";

<details>
  <summary>📝 模块更新日志</summary>
  <div>
<div>

- **新特性**

  - &nbsp;<Tag>新增</Tag> 定时任务间隔分钟作业触发器 `Triggers.PeriodMinutes(5)` 和 `[PeriodMinutes(5)]` 特性 <sup>4.8.2.8</sup> <sup>⏱️2022.12.01</sup> [8e1f06f](https://gitee.com/dotnetchina/Furion/commit/8e1f06fa2161ee2bf8bcea29af8aaa5a60ef9db9)
  - &nbsp;<Tag>新增</Tag> 定时任务工作日作业触发器 `Triggers.Workday()` 和 `[Workday]` 特性 <sup>4.8.2.6</sup> <sup>⏱️2022.11.30</sup> [28b2d20](https://gitee.com/dotnetchina/Furion/commit/28b2d20b3f6034a4cdf5827576c34412315fbb15)
  - &nbsp;<Tag>新增</Tag> 定时任务作业校对功能，可对误差进行校正 <sup>4.8.2.6</sup> <sup>⏱️2022.11.30</sup> [f725a25](https://gitee.com/dotnetchina/Furion/commit/f725a252e6a89f9dea6489d4e54452077b1935e5)
  - &nbsp;<Tag>新增</Tag> **定时任务 `Triggers` 所有带 `At` 的 `Cron` 表达式触发器构建器及特性** <sup>4.8.2.5</sup> <sup>⏱️2022.11.29</sup> [#I63PLR](https://gitee.com/dotnetchina/Sundial/issues/I63PLR)
  - &nbsp;<Tag>新增</Tag> 定时任务批量添加 `SchedulerBuilder` 作业功能 <sup>4.8.2.4</sup> <sup>⏱️2022.11.29</sup> [5faa67b](https://gitee.com/dotnetchina/Furion/commit/5faa67b7817459cb0ee0add86a6e53c17ff51a05)
  - &nbsp;<Tag>新增</Tag> 定时任务 `BuildSqlType` 配置，可设置生成不同数据库类型的 `SQL` 语句 <sup>4.8.2.3</sup> <sup>⏱️2022.11.29</sup> [293f9bc](https://gitee.com/dotnetchina/Furion/commit/293f9bce34fc4f70eacae1043ed697d31da88409) [!675](https://gitee.com/dotnetchina/Furion/pulls/675)
  - &nbsp;<Tag>新增</Tag> `JobDetail` 和 `Trigger` 自定义 `ConvertToSQL` 输出 `SQL` 配置 <sup>4.8.2</sup> <sup>⏱️2022.11.27</sup> [0bb9d8f](https://gitee.com/dotnetchina/Furion/commit/0bb9d8f1f3606af145b44c2984b87fdc020f02e1)
  - &nbsp;<Tag>新增</Tag> **作业触发器 `ResetOnlyOnce` 属性，支持只运行一次的作业重新启动服务重复执行** <sup>4.8.1.5</sup> <sup>⏱️2022.11.25</sup> [a8be728](https://gitee.com/dotnetchina/Furion/commit/a8be728eac986ebc5f44718b08c67aaee8b89dc6)
  - &nbsp;<Tag>新增</Tag> 动态作业处理程序委托支持 <sup>4.8.1.8</sup> <sup>⏱️2022.11.27</sup> [e02266c](https://gitee.com/dotnetchina/Furion/commit/e02266c44187dbc2b416abe1ca4112ce13c89180)

- **问题修复**

  - &nbsp;<Tag>修复</Tag> 作业触发器不符合下一次执行规律但 `NextRunTime` 不为 `null` 情况 <sup>4.8.1.5</sup> <sup>⏱️2022.11.25</sup> [a8be728](https://gitee.com/dotnetchina/Furion/commit/a8be728eac986ebc5f44718b08c67aaee8b89dc6)
  - &nbsp;<Tag>修复</Tag> 运行时启动/暂停作业无效问题 <sup>4.8.1.6</sup> <sup>⏱️2022.11.25</sup> [#I6368M](https://gitee.com/dotnetchina/Furion/issues/I6368M)
  - &nbsp;<Tag>修复</Tag> 定时任务生成的 `SQL` 语句不支持 `MySQL` 问题 <sup>4.8.1.7</sup> <sup>⏱️2022.11.26</sup> [#I638ZC](https://gitee.com/dotnetchina/Furion/issues/I638ZC)

- **其他更改**

  - &nbsp;<Tag>调整</Tag> 定时任务调度器时间精度，控制持续执行一年误差在 `100ms` 以内 <sup>4.8.2.9</sup> <sup>⏱️2022.12.01</sup> [334d089](https://gitee.com/dotnetchina/Furion/commit/334d08989503bacd8bf2abb2cc87cf2031dc9da6)
  - &nbsp;<Tag>调整</Tag> 定时任务作业计划工厂 `GetNextRunJobs()` 方法逻辑 <sup>4.8.2.7</sup> <sup>⏱️2022.11.30</sup> [#I63VS2](https://gitee.com/dotnetchina/Furion/issues/I63VS2)

- **文档**

  - &nbsp;<Tag>新增</Tag> 作业触发器 `ResetOnlyOnce` 文档 <sup>4.8.1.5</sup> <sup>⏱️2022.11.25</sup> [a8be728](https://gitee.com/dotnetchina/Furion/commit/a8be728eac986ebc5f44718b08c67aaee8b89dc6)
  - &nbsp;<Tag>新增</Tag> **通过 `Roslyn` 动态编译代码创建 `IJob` 类型文档** <sup>4.8.1.5</sup> <sup>⏱️2022.11.25</sup> [2c5e5be](https://gitee.com/dotnetchina/Furion/commit/2c5e5befc7a335d6ef0e75eea0061aee1e4dd061)
  - &nbsp;<Tag>新增</Tag> 自定义 `JobDetail` 和 `Trigger` 输出 `SQL` 文档 <sup>4.8.2</sup> <sup>⏱️2022.11.27</sup> [0bb9d8f](https://gitee.com/dotnetchina/Furion/commit/0bb9d8f1f3606af145b44c2984b87fdc020f02e1)

</div>
  </div>
</details>

:::warning 4.8.0 以下版本说明

**在 `Furion 4.8.0+` 版本采用 [Sundial](https://gitee.com/dotnetchina/Sundial) 定时任务替换原有的 `TaskScheduler`**，[查看旧文档](/docs/job-old)

:::

:::important 版本说明

以下内容仅限 `Furion 4.8.0 +` 版本使用。

:::

import useBaseUrl from "@docusaurus/useBaseUrl";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

## 26.1.1 关于调度作业

调度作业又称定时任务，顾名思义，定时任务就是在特定的时间或符合某种时间规律自动触发并执行任务。

<img src={useBaseUrl("img/scdr.png")} />

## 26.1.2 快速入门

1. 定义作业处理程序 `MyJob`：

```cs showLineNumbers {1,9,11}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context}");
        return Task.CompletedTask;
    }
}
```

2. 在 `Startup.cs` 注册 `Schedule` 服务：

```cs showLineNumbers {1,3-4}
services.AddSchedule(options =>
{
    // 注册作业，并配置作业触发器
    options.AddJob<MyJob>(Triggers.Secondly()); // 表示每秒执行
});
```

3. 查看作业执行结果

```bash showLineNumbers {6,8,10,12,14,16,18}
info: 2022-12-02 16:51:33.5032989 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is running.
info: 2022-12-02 16:51:33.5180669 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is preloading......
info: 2022-12-02 16:51:34.1452041 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger1> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 16:51:34.1541701 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The scheduler of <job1> successfully appended to the schedule.
warn: 2022-12-02 16:51:34.1748401 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service preload completed, and a total of <1> schedulers are appended.
info: 2022-12-02 16:51:35.0712571 +08:00 星期五 L MyJob[0] #4
      <job1> [C] <job1 job1_trigger1> * * * * * * 1ts 2022-12-02 16:51:35.000 -> 2022-12-02 16:51:36.000
info: 2022-12-02 16:51:36.0317375 +08:00 星期五 L MyJob[0] #14
      <job1> [C] <job1 job1_trigger1> * * * * * * 2ts 2022-12-02 16:51:36.000 -> 2022-12-02 16:51:37.000
info: 2022-12-02 16:51:37.0125007 +08:00 星期五 L MyJob[0] #9
      <job1> [C] <job1 job1_trigger1> * * * * * * 3ts 2022-12-02 16:51:37.000 -> 2022-12-02 16:51:38.000
info: 2022-12-02 16:51:38.0179920 +08:00 星期五 L MyJob[0] #8
      <job1> [C] <job1 job1_trigger1> * * * * * * 4ts 2022-12-02 16:51:38.000 -> 2022-12-02 16:51:39.000
```

`JobExecutionContext` 重写了 `ToString()` 方法并提供以下几种格式：

```bash showLineNumbers {2,5}
# 持续运行格式
<作业Id> [并行C/串行S] <作业Id 触发器Id> 触发器字符串 触发器描述 触发次数ts 触发时间 -> 下一次触发时间

# 触发停止格式
<作业Id> [并行C/串行S] <作业Id 触发器Id> 触发器字符串 触发器描述 触发次数ts 触发时间 [触发器终止状态]
```

### 26.1.2.1 指定作业 `Id`

默认情况下，不指定作业 `Id` 会自动生成 `job[编号]`。

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>("myjob", Triggers.Secondly());
});
```

查看作业执行结果：

```bash showLineNumbers {6,8,12,14,16}
info: 2022-12-02 17:15:43.3024818 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is running.
info: 2022-12-02 17:15:43.3107918 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is preloading......
info: 2022-12-02 17:15:43.9498664 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <myjob_trigger1> trigger for scheduler of <myjob> successfully appended to the schedule.
info: 2022-12-02 17:15:43.9532894 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The scheduler of <myjob> successfully appended to the schedule.
warn: 2022-12-02 17:15:43.9941565 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service preload completed, and a total of <1> schedulers are appended.
info: 2022-12-02 17:15:44.1230353 +08:00 星期五 L MyJob[0] #6
      <myjob> [C] <myjob myjob_trigger1> * * * * * * 1ts 2022-12-02 17:15:44.000 -> 2022-12-02 17:15:45.000
info: 2022-12-02 17:15:45.0854893 +08:00 星期五 L MyJob[0] #9
      <myjob> [C] <myjob myjob_trigger1> * * * * * * 2ts 2022-12-02 17:15:45.000 -> 2022-12-02 17:15:46.000
info: 2022-12-02 17:15:46.0100813 +08:00 星期五 L MyJob[0] #13
      <myjob> [C] <myjob myjob_trigger1> * * * * * * 3ts 2022-12-02 17:15:46.000 -> 2022-12-02 17:15:47.000
```

### 26.1.2.2 多个作业触发器

有时候，一个作业支持多种触发时间，比如 `每分钟` 执行一次，每 `5秒` 执行一次，每分钟第 `3/7/8秒` 执行一次。

```cs showLineNumbers {3-5}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(Triggers.Minutely()   // 每分钟开始
     , Triggers.Period(5000)   // 每 5 秒，还支持 Triggers.PeriodSeconds(5)，Triggers.PeriodMinutes(5)，Triggers.PeriodHours(5)
     , Triggers.Cron("3,7,8 * * * * ?", CronStringFormat.WithSeconds));  // 每分钟第 3/7/8 秒
});
```

查看作业执行结果：

```cs showLineNumbers {6,8,10,12,16,18,20,24,26}
info: 2022-12-02 17:18:53.3593518 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is running.
info: 2022-12-02 17:18:53.3663583 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is preloading......
info: 2022-12-02 17:18:54.0381456 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger1> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 17:18:54.0708796 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger2> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 17:18:54.0770193 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger3> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 17:18:54.0800017 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The scheduler of <job1> successfully appended to the schedule.
warn: 2022-12-02 17:18:54.1206816 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service preload completed, and a total of <1> schedulers are appended.
info: 2022-12-02 17:18:59.0040452 +08:00 星期五 L MyJob[0] #9
      <job1> [C] <job1 job1_trigger2> 5000ms 1ts 2022-12-02 17:18:58.927 -> 2022-12-02 17:19:03.944
info: 2022-12-02 17:19:00.0440142 +08:00 星期五 L MyJob[0] #15
      <job1> [C] <job1 job1_trigger1> * * * * * 1ts 2022-12-02 17:19:00.000 -> 2022-12-02 17:20:00.000
info: 2022-12-02 17:19:03.0149075 +08:00 星期五 L MyJob[0] #6
      <job1> [C] <job1 job1_trigger3> 3,7,8 * * * * ? 1ts 2022-12-02 17:19:03.000 -> 2022-12-02 17:19:07.000
info: 2022-12-02 17:19:03.9519350 +08:00 星期五 L MyJob[0] #15
      <job1> [C] <job1 job1_trigger2> 5000ms 2ts 2022-12-02 17:19:03.944 -> 2022-12-02 17:19:08.919
info: 2022-12-02 17:19:07.0116797 +08:00 星期五 L MyJob[0] #4
      <job1> [C] <job1 job1_trigger3> 3,7,8 * * * * ? 2ts 2022-12-02 17:19:07.000 -> 2022-12-02 17:19:08.000
info: 2022-12-02 17:19:08.0078132 +08:00 星期五 L MyJob[0] #15
      <job1> [C] <job1 job1_trigger3> 3,7,8 * * * * ? 3ts 2022-12-02 17:19:08.000 -> 2022-12-02 17:20:03.000
info: 2022-12-02 17:19:08.9298393 +08:00 星期五 L MyJob[0] #14
      <job1> [C] <job1 job1_trigger2> 5000ms 3ts 2022-12-02 17:19:08.919 -> 2022-12-02 17:19:13.897
info: 2022-12-02 17:19:13.9056247 +08:00 星期五 L MyJob[0] #8
      <job1> [C] <job1 job1_trigger2> 5000ms 4ts 2022-12-02 17:19:13.897 -> 2022-12-02 17:19:18.872
info: 2022-12-02 17:19:18.8791123 +08:00 星期五 L MyJob[0] #12
      <job1> [C] <job1 job1_trigger2> 5000ms 5ts 2022-12-02 17:19:18.872 -> 2022-12-02 17:19:23.846
```

### 26.1.2.3 `串行` 执行

默认情况下，作业采用 `并行` 执行方式，也就是不会等待上一次作业执行完成，只要触发时间到了就自动执行，但一些情况下，我们可能希望等待上一次作业完成再执行，如：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(concurrent: false, Triggers.Secondly()); // 串行，每秒执行
});
```

```cs showLineNumbers {12}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.Delay(2000, stoppingToken); // 这里模拟耗时操作，比如耗时2秒
    }
}
```

查看作业执行结果：

```cs showLineNumbers {6,8,12,14,16,18,20}
info: 2022-12-02 17:23:27.3726863 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is running.
info: 2022-12-02 17:23:27.3830366 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is preloading......
info: 2022-12-02 17:23:27.9083148 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger1> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 17:23:27.9184699 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The scheduler of <job1> successfully appended to the schedule.
warn: 2022-12-02 17:23:27.9740028 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service preload completed, and a total of <1> schedulers are appended.
info: 2022-12-02 17:23:28.0638789 +08:00 星期五 L MyJob[0] #9
      <job1> [S] <job1 job1_trigger1> * * * * * * 1ts 2022-12-02 17:23:28.000 -> 2022-12-02 17:23:29.000
warn: 2022-12-02 17:23:29.1119269 +08:00 星期五 L System.Logging.ScheduleService[0] #9
      12/02/2022 17:23:29: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
warn: 2022-12-02 17:23:30.0090551 +08:00 星期五 L System.Logging.ScheduleService[0] #9
      12/02/2022 17:23:30: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
info: 2022-12-02 17:23:31.0121694 +08:00 星期五 L MyJob[0] #9
      <job1> [S] <job1 job1_trigger1> * * * * * * 2ts 2022-12-02 17:23:31.000 -> 2022-12-02 17:23:32.000
warn: 2022-12-02 17:23:32.0243646 +08:00 星期五 L System.Logging.ScheduleService[0] #9
      12/02/2022 17:23:32: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
```

:::caution `串行` 执行规则说明

`串行` 执行如果遇到上一次作业还未完成那么它会等到下一次触发时间到了再执行，以此重复。

:::

默认情况下，使用 `串行` 执行但因为耗时导致**触发时间到了但实际未能执行**会默认输出 `warn` 警告日志，如需关闭只需要：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.LogEnabled = false;
    options.AddJob<MyJob>(concurrent: false, Triggers.Secondly()); // 每秒执行
});
```

查看作业执行结果：

```bash showLineNumbers {2,4,6,8,10}
info: 2022-12-02 17:27:13.1136450 +08:00 星期五 L MyJob[0] #12
      <job1> [S] <job1 job1_trigger1> * * * * * * 1ts 2022-12-02 17:27:13.000 -> 2022-12-02 17:27:14.000
info: 2022-12-02 17:27:16.0092433 +08:00 星期五 L MyJob[0] #8
      <job1> [S] <job1 job1_trigger1> * * * * * * 2ts 2022-12-02 17:27:16.000 -> 2022-12-02 17:27:17.000
info: 2022-12-02 17:27:19.0092363 +08:00 星期五 L MyJob[0] #6
      <job1> [S] <job1 job1_trigger1> * * * * * * 3ts 2022-12-02 17:27:19.000 -> 2022-12-02 17:27:20.000
info: 2022-12-02 17:27:22.0183594 +08:00 星期五 L MyJob[0] #9
      <job1> [S] <job1 job1_trigger1> * * * * * * 4ts 2022-12-02 17:27:22.000 -> 2022-12-02 17:27:23.000
info: 2022-12-02 17:27:25.0152323 +08:00 星期五 L MyJob[0] #4
      <job1> [S] <job1 job1_trigger1> * * * * * * 5ts 2022-12-02 17:27:25.000 -> 2022-12-02 17:27:26.000
```

### 26.1.2.4 打印作业完整信息

框架提供了四种方式打印作业完整信息。

- **第一种：输出完整的作业 `JSON` 信息：`context.ConvertToJSON()`**

```cs showLineNumbers {11}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation(context.ConvertToJSON());
        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```json showLineNumbers {3,14}
info: 2022-12-02 18:00:59.4140802 +08:00 星期五 L MyJob[0] #13
      {
        "jobDetail": {
        "jobId": "job1",
        "groupName": null,
        "jobType": "MyJob",
        "assemblyName": "ConsoleApp32",
        "description": null,
        "concurrent": true,
        "includeAnnotations": false,
        "properties": "{}",
        "updatedTime": "2022-12-02 18:00:59.390"
      },
        "trigger": {
        "triggerId": "job1_trigger1",
        "jobId": "job1",
        "triggerType": "Furion.Schedule.PeriodSecondsTrigger",
        "assemblyName": "Furion",
        "args": "[5]",
        "description": null,
        "status": 2,
        "startTime": null,
        "endTime": null,
        "lastRunTime": "2022-12-02 18:00:59.326",
        "nextRunTime": "2022-12-02 18:01:04.358",
        "numberOfRuns": 1,
        "maxNumberOfRuns": 0,
        "numberOfErrors": 0,
        "maxNumberOfErrors": 0,
        "numRetries": 0,
        "retryTimeout": 1000,
        "startNow": true,
        "runOnStart": false,
        "resetOnlyOnce": true,
        "updatedTime": "2022-12-02 18:00:59.390"
      }
      }
```

- **第二种：输出单独的作业 `JSON` 信息：`jobDetail.ConvertToJSON()` 或 `trigger.ConvertToJSON()`**

```cs showLineNumbers {11-12}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation(context.JobDetail.ConvertToJSON());
        _logger.LogInformation(context.Trigger.ConvertToJSON(NamingConventions.UnderScoreCase));    // 支持三种属性名输出规则

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```json showLineNumbers {2-12,14-35}
info: 2022-12-02 18:02:10.7923360 +08:00 星期五 L MyJob[0] #8
      {
        "jobId": "job1",
        "groupName": null,
        "jobType": "MyJob",
        "assemblyName": "ConsoleApp32",
        "description": null,
        "concurrent": true,
        "includeAnnotations": false,
        "properties": "{}",
        "updatedTime": "2022-12-02 18:02:10.774"
      }
info: 2022-12-02 18:02:10.8008708 +08:00 星期五 L MyJob[0] #8
      {
        "trigger_id": "job1_trigger1",
        "job_id": "job1",
        "trigger_type": "Furion.Schedule.PeriodSecondsTrigger",
        "assembly_name": "Furion",
        "args": "[5]",
        "description": null,
        "status": 2,
        "start_time": null,
        "end_time": null,
        "last_run_time": "2022-12-02 18:02:10.727",
        "next_run_time": "2022-12-02 18:02:15.733",
        "number_of_runs": 1,
        "max_number_of_runs": 0,
        "number_of_errors": 0,
        "max_number_of_errors": 0,
        "num_retries": 0,
        "retry_timeout": 1000,
        "start_now": true,
        "run_on_start": false,
        "reset_only_once": true,
        "updated_time": "2022-12-02 18:02:10.774"
      }
```

- **第三种：输出单独的作业 `SQL` 信息：`jobDetail.ConvertToSQL()` 或 `trigger.ConvertToSQL()`**

```cs showLineNumbers {11-12,14-16}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;
        var trigger = context.Trigger;

        _logger.LogInformation(jobDetail.ConvertToSQL("作业信息表名", PersistenceBehavior.Appended));  // 输出新增语句
        _logger.LogInformation(trigger.ConvertToSQL("作业触发器表名", PersistenceBehavior.Removed, NamingConventions.Pascal));    // 输出删除语句
        _logger.LogInformation(trigger.ConvertToSQL("作业触发器表名", PersistenceBehavior.Updated, NamingConventions.UnderScoreCase));    // 输出更新语句

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```sql showLineNumbers {2,25,28}
info: 2022-12-02 18:03:11.8543760 +08:00 星期五 L MyJob[0] #13
      INSERT INTO 作业信息表名(
          jobId,
          groupName,
          jobType,
          assemblyName,
          description,
          concurrent,
          includeAnnotations,
          properties,
          updatedTime
      )
      VALUES(
          'job1',
          NULL,
          'MyJob',
          'ConsoleApp32',
          NULL,
          1,
          0,
          '{}',
          '2022-12-02 18:03:11.836'
      );
info: 2022-12-02 18:03:11.8636268 +08:00 星期五 L MyJob[0] #13
      DELETE FROM 作业触发器表名
      WHERE TriggerId = 'job1_trigger1' AND JobId = 'job1';
info: 2022-12-02 18:03:11.8669134 +08:00 星期五 L MyJob[0] #13
      UPDATE 作业触发器表名
      SET
          trigger_id = 'job1_trigger1',
          job_id = 'job1',
          trigger_type = 'Furion.Schedule.PeriodSecondsTrigger',
          assembly_name = 'Furion',
          args = '[5]',
          description = NULL,
          status = 2,
          start_time = NULL,
          end_time = NULL,
          last_run_time = '2022-12-02 18:03:11.778',
          next_run_time = '2022-12-02 18:03:16.794',
          number_of_runs = 1,
          max_number_of_runs = 0,
          number_of_errors = 0,
          max_number_of_errors = 0,
          num_retries = 0,
          retry_timeout = 1000,
          start_now = 1,
          run_on_start = 0,
          reset_only_once = 1,
          updated_time = '2022-12-02 18:03:11.836'
      WHERE trigger_id = 'job1_trigger1' AND job_id = 'job1';
```

- **第四种：输出单独的作业 `Monitor` 信息：`jobDetail.ConvertToMonitor()` 或 `trigger.ConvertToMonitor()`**

```cs showLineNumbers {11-12}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation(context.JobDetail.ConvertToMonitor());
        _logger.LogInformation(context.Trigger.ConvertToMonitor());

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```bash showLineNumbers {2,16}
info: 2022-12-02 18:04:06.2833095 +08:00 星期五 L MyJob[0] #8
      ┏━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
      ┣ MyJob
      ┣
      ┣ jobId：                     job1
      ┣ groupName：
      ┣ jobType：                   MyJob
      ┣ assemblyName：              ConsoleApp32
      ┣ description：
      ┣ concurrent：                True
      ┣ includeAnnotations：        False
      ┣ properties：                {}
      ┣ updatedTime：               2022-12-02 18:04:06.254
      ┗━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
info: 2022-12-02 18:04:06.2868205 +08:00 星期五 L MyJob[0] #8
      ┏━━━━━━━━━━━  Trigger ━━━━━━━━━━━
      ┣ Furion.Schedule.PeriodSecondsTrigger
      ┣
      ┣ triggerId：                job1_trigger1
      ┣ jobId：                    job1
      ┣ triggerType：              Furion.Schedule.PeriodSecondsTrigger
      ┣ assemblyName：             Furion
      ┣ args：                     [5]
      ┣ description：
      ┣ status：                   Running
      ┣ startTime：
      ┣ endTime：
      ┣ lastRunTime：              2022-12-02 18:04:06.189
      ┣ nextRunTime：              2022-12-02 18:04:11.212
      ┣ numberOfRuns：             1
      ┣ maxNumberOfRuns：          0
      ┣ numberOfErrors：           0
      ┣ maxNumberOfErrors：        0
      ┣ numRetries：               0
      ┣ retryTimeout：             1000
      ┣ startNow：                 True
      ┣ runOnStart：               False
      ┣ resetOnlyOnce：            True
      ┣ updatedTime：              2022-12-02 18:04:06.254
      ┗━━━━━━━━━━━  Trigger ━━━━━━━━━━━
```

### 26.1.2.5 运行时（动态）操作作业

有时候，我们需要在运行时对作业动态的增加，更新，删除等操作，如动态添加作业：

1. 注册 `services.AddSchedule()` 服务

```cs showLineNumbers {2,5}
// 可以完全动态操作，只需要注册服务即可
services.AddSchedule();

// 也可以部分静态，部分动态注册
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(concurrent: false, Triggers.PeriodSeconds(5));
});
```

2. 注入 `ISchedulerFactory` 服务

```cs showLineNumbers {4,11}
public class YourService: IYourService
{
    private readonly ISchedulerFactory _schedulerFactory;
    public YourService(ISchedulerFactory schedulerFactory)
    {
        _schedulerFactory = schedulerFactory;
    }

    public void AddJob()
    {
        _schedulerFactory.AddJob<MyJob>("动态作业 Id", Triggers.Secondly());
    }
}
```

3. 查看作业执行结果

```bash showLineNumbers {6,8,12,14,16,18,22,24}
info: 2022-12-02 18:07:33.7799062 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is running.
info: 2022-12-02 18:07:33.7971487 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is preloading......
info: 2022-12-02 18:07:33.8751390 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger1> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 18:07:33.8805159 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The scheduler of <job1> successfully appended to the schedule.
warn: 2022-12-02 18:07:33.9013656 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service preload completed, and a total of <1> schedulers are appended.
info: 2022-12-02 18:07:38.9241031 +08:00 星期五 L MyJob[0] #9
      <job1> [C] <job1 job1_trigger1> 5s 1ts 2022-12-02 18:07:38.813 -> 2022-12-02 18:07:43.863
info: 2022-12-02 18:07:43.0865787 +08:00 星期五 L System.Logging.ScheduleService[0] #16
      The <动态作业 Id_trigger1> trigger for scheduler of <动态作业 Id> successfully appended to the schedule.
warn: 2022-12-02 18:07:43.0894163 +08:00 星期五 L System.Logging.ScheduleService[0] #16
      Schedule hosted service cancels hibernation and GC.Collect().
info: 2022-12-02 18:07:43.1129824 +08:00 星期五 L System.Logging.ScheduleService[0] #16
      The scheduler of <动态作业 Id> successfully appended to the schedule.
info: 2022-12-02 18:07:43.8810686 +08:00 星期五 L MyJob[0] #17
      <job1> [C] <job1 job1_trigger1> 5s 2ts 2022-12-02 18:07:43.863 -> 2022-12-02 18:07:48.848
info: 2022-12-02 18:07:44.0104025 +08:00 星期五 L MyJob[0] #16
      <动态作业 Id> [C] <动态作业 Id 动态作业 Id_trigger1> * * * * * * 1ts 2022-12-02 18:07:44.000 -> 2022-12-02 18:07:45.000
info: 2022-12-02 18:07:45.0092441 +08:00 星期五 L MyJob[0] #8
      <动态作业 Id> [C] <动态作业 Id 动态作业 Id_trigger1> * * * * * * 2ts 2022-12-02 18:07:45.000 -> 2022-12-02 18:07:46.000
```

### 26.1.2.6 作业触发器特性

默认情况下，框架不会扫描 `IJob` 实现类的作业触发器特性，但可以设置作业的 `IncludeAnnotations` 进行启用。

1. 启用 `IncludeAnnotations` 扫描

```cs showLineNumbers {3,7,10}
services.AddSchedule(options =>
{
    options.AddJob(JobBuilder.Create<MyJob>().SetIncludeAnnotations(true)
        , Triggers.PeriodSeconds(5));     // 这里可传可不传，传了则会自动载入特性和这里配置的作业触发器

    // 还可以更简单~~
    options.AddJob(typeof(MyJob).ScanToBuilder());

    // 还可以批量新增 Furion 4.8.2.4+
    options.AddJob(App.EffectiveTypes.ScanToBuilders().ToArray())
});
```

2. 在 `MyJob` 中添加多个作业触发器特性

```cs showLineNumbers {1-2}
[Minutely]
[Cron("3,7,8 * * * * ?", CronStringFormat.WithSeconds)]
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context}");
        await Task.CompletedTask;
    }
}
```

3. 查看作业执行结果

```bash showLineNumbers {6,8,10,12,16,18,20,24,26}
info: 2022-12-02 18:12:56.4199663 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is running.
info: 2022-12-02 18:12:56.4287962 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is preloading......
info: 2022-12-02 18:12:56.6149505 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger1> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 18:12:56.6205117 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger2> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 18:12:56.6266132 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The <job1_trigger3> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-02 18:12:56.6291006 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The scheduler of <job1> successfully appended to the schedule.
warn: 2022-12-02 18:12:56.6454334 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule hosted service preload completed, and a total of <1> schedulers are appended.
info: 2022-12-02 18:13:00.0842828 +08:00 星期五 L MyJob[0] #15
      <job1> [C] <job1 job1_trigger2> * * * * * 1ts 2022-12-02 18:13:00.000 -> 2022-12-02 18:14:00.000
info: 2022-12-02 18:13:01.5260220 +08:00 星期五 L MyJob[0] #16
      <job1> [C] <job1 job1_trigger1> 5s 1ts 2022-12-02 18:13:01.494 -> 2022-12-02 18:13:06.492
info: 2022-12-02 18:13:03.0076111 +08:00 星期五 L MyJob[0] #6
      <job1> [C] <job1 job1_trigger3> 3,7,8 * * * * ? 1ts 2022-12-02 18:13:03.000 -> 2022-12-02 18:13:07.000
info: 2022-12-02 18:13:06.4954400 +08:00 星期五 L MyJob[0] #13
      <job1> [C] <job1 job1_trigger1> 5s 2ts 2022-12-02 18:13:06.492 -> 2022-12-02 18:13:11.463
info: 2022-12-02 18:13:07.0180453 +08:00 星期五 L MyJob[0] #6
      <job1> [C] <job1 job1_trigger3> 3,7,8 * * * * ? 2ts 2022-12-02 18:13:07.000 -> 2022-12-02 18:13:08.000
info: 2022-12-02 18:13:08.0114292 +08:00 星期五 L MyJob[0] #13
      <job1> [C] <job1 job1_trigger3> 3,7,8 * * * * ? 3ts 2022-12-02 18:13:08.000 -> 2022-12-02 18:14:03.000
info: 2022-12-02 18:13:11.4774564 +08:00 星期五 L MyJob[0] #16
      <job1> [C] <job1 job1_trigger1> 5s 3ts 2022-12-02 18:13:11.463 -> 2022-12-02 18:13:16.445
```

## 26.1.3 作业信息 `JobDetail` 及构建器

### 26.1.3.1 关于作业信息

框架提供了 `JobDetail` 类型来描述作业信息，`JobDetail` 类型提供以下**只读属性**：

| 属性名               | 属性类型    | 默认值  | 说明                                                                     |
| -------------------- | ----------- | ------- | ------------------------------------------------------------------------ |
| `JobId`              | `string`    |         | 作业 `Id`                                                                |
| `GroupName`          | `string`    |         | 作业组名称                                                               |
| `JobType`            | `string`    |         | 作业处理程序类型，存储的是类型的 `FullName`                              |
| `AssemblyName`       | `string`    |         | 作业处理程序类型所在程序集，存储的是程序集 `Name`                        |
| `Description`        | `string`    |         | 描述信息                                                                 |
| `Concurrent`         | `bool`      | `true`  | 作业执行方式，如果设置为 `false`，那么使用 `串行` 执行，否则 `并行` 执行 |
| `IncludeAnnotations` | `bool`      | `false` | 是否扫描 `IJob` 实现类 `[Trigger]` 特性触发器                            |
| `Properties`         | `string`    | `"{}"`  | 作业信息额外数据，由 `Dictionary<string, object>` 序列化成字符串存储     |
| `UpdatedTime`        | `DateTime?` |         | 作业更新时间                                                             |

### 26.1.3.2 关于作业信息构建器

作业信息 `JobDetail` 是作业调度模块提供运行时的**只读类型**，那么我们该如何创建或变更 `JobDetail` 对象呢？

`JobBuilder` 是作业调度模块提供可用来生成运行时 `JobDetail` 的类型，这样做的好处可避免外部直接修改运行时 `JobDetail` 数据，还能实现任何修改动作监听，也能避免多线程抢占情况。

作业调度模块提供了多种方式用来创建 `JobBuilder` 对象。

1. **通过 `Create` 静态方法创建**

```cs showLineNumbers {2,5,8,11,14}
// 根据作业 Id 创建
var jobBuilder = JoBuilder.Create("job1");

// 根据 IJob 实现类类型创建
var jobBuilder = JobBuilder.Create<MyJob>();

// 根据程序集名称和类型完全限定名（FullName）创建
var jobBuilder = JobBuilder.Create("YourProject", "YourProject.MyJob");

// 根据 Type 类型创建
var jobBuilder = JobBuilder.Create(typeof(MyJob));

// 通过委托创造动态作业
var jobBuilder = JoBuilder.Create((serviceProvider, context, stoppingToken) =>
{
      serviceProvider.GetLogger().LogInformation($"{context}");
      return Task.CompletedTask;
});
```

2. **通过 `JobDetail` 类型创建**

这种方式常用于在运行时更新作业信息。

```cs showLineNumbers
var jobBuilder = JobBuilder.From(jobDetail);

//也可以通过以下方式
var jobBuilder = jobDetail.GetBuilder();
```

3. **通过 `JSON` 字符串创建**

该方式非常灵活，可从配置文件，`JSON` 字符串，或其他能够返回 `JSON` 字符串的地方创建。

```cs showLineNumbers {2-12}
var jobBuilder = JobBuilder.From(@"{
	""jobId"": ""job1"",
	""groupName"": null,
	""jobType"": ""MyJob"",
	""assemblyName"": ""ConsoleApp13"",
	""description"": null,
	""concurrent"": true,
	""includeAnnotations"": false,
	""properties"": ""{}"",
	""updatedTime"": null
}");
```

如果使用的是 `.NET7`，可使用 `"""` 避免转义，如：

```cs showLineNumbers {2-12}
var jobBuilder = JobBuilder.From("""
{
	"jobId": "job1",
	"groupName": null,
	"jobType": "MyJob",
	"assemblyName": "ConsoleApp13",
	"description": null,
	"concurrent": true,
	"includeAnnotations": false,
	"properties": "{}",
	"updatedTime": "2022-12-02 18:00:59.390"
}
""");
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 命名方式。

**不支持 `UnderScoreCase（下划线命名法）`** ，如 `"include_annotations": true`

:::

4. **还可以通过 `Clone` 静态方法从一个 `JobBuilder` 创建**

```cs showLineNumbers
var jobBuilder = JobBuilder.Clone(fromJobBuilder);
```

:::important 克隆说明

克隆操作只会克隆 `AssemblyName`，`JobType`，`GroupName`，`Description`，`Concurrent`，`IncludeAnnotations`，`Properties`，`DynamicExecuteAsync`（动态作业）。

- **不会克隆 `JobId`，`UpdatedTime`。**

:::

5. **还可以通过 `LoadFrom` 实例方法填充当前的 `JobBuilder`**

比如可以传递匿名类型，类类型，字典 `Dictionary<string, object>` 类型：

```cs showLineNumbers {2,9,14,17,22,25}
// 会覆盖所有相同的值
jobBuilder.LoadFrom(new
{
      Description = "我是描述",
      Concurrent = false
});

// 支持多个填充，还可以配置跳过 null 值覆盖
jobBuilder.LoadFrom(new
{
      Description = "我是另外一个描述",
      Concurrent = false,
      IncludeAnnotations = default(object)      // 会跳过赋值
}, ignoreNullValue: true);

// 支持忽略特定属性名映射
jobBuilder.LoadFrom(new
{
      Description = "我是另外一个描述",
      Concurrent = false,
      IncludeAnnotations = default(object)      // 会跳过赋值
}, ignorePropertyNames: new[]{ "description" });

// 支持字典类型
jobBuilder.LoadFrom(new Dictionary<string, object>
{
      {"Description", "这是新的描述" },
      {"include_annotations", false },
      {"updatedTime", DateTime.Now }
})
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 和 `UnderScoreCase（下划线命名法）` 命名方式。

:::

### 26.1.3.3 设置作业信息构建器

`JobBuilder` 提供了和 `JobDetail` 完全匹配的 `Set[属性名]` 方法来配置作业信息各个属性，如：

```cs showLineNumbers {3,20}
services.AddSchedule(options =>
{
    var jobBuilder = JobBuilder.Create<MyJob>()
        .SetJobId("job1")   // 作业 Id
        .SetGroupName("group1") // 作业组名称
        .SetJobType("Furion.Application", "Furion.Application.MyJob") // 作业类型，支持多个重载
        .SetJobType<MyJob>()    // 作业类型，支持多个重载
        .SetJobType(typeof(MyJob))  // 作业类型，支持多个重载
        .SetDescription("这是一段描述")   // 作业描述
        .SetConcurrent(false)   // 并行还是串行方式，false 为 串行
        .SetIncludeAnnotations(true)    // 是否扫描 IJob 类型的触发器特性，true 为 扫描
        .SetProperties("{}")    // 作业额外数据 Dictionary<string, object> 类型序列化，支持多个重载
        .SetProperties(new Dictionary<string, object> { { "name", "Furion" } })  // 作业类型额外数据，支持多个重载，推荐！！！
        .SetDynamicExecuteAsync((serviceProvider, context, stoppingToken) => {
            serviceProvider.GetLogger().LogInformation($"{context}");
            return Task.CompletedTask;
        })  // 动态委托处理程序，一旦设置了此委托，那么优先级将大于 MyJob 的 ExecuteAsync
        ;

    options.AddJob(jobBuilder, Triggers.PeriodSeconds(5));
});
```

### 26.1.3.4 作业信息/构建器额外数据

有时候我们需要在作业运行的时候添加一些额外数据，或者实现多个触发器共享数据，经常用于 `串行` 执行中（`并行` 也同样工作），后面一个触发器需等待前一个触发器完成。

```cs showLineNumbers {13-14,16}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;

        var count = jobDetail.GetProperty<int>("count");
        jobDetail.AddOrUpdateProperty("count", count + 1);  // 递增 count

        _logger.LogInformation($"count: {count} {context}");

        await Task.CompletedTask;
    }
}
```

查看作业运行日志：

```bash showLineNumbers {12,14,16,18}
info: 2022-12-03 23:16:46.5150228 +08:00 星期六 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is running.
info: 2022-12-03 23:16:46.5197497 +08:00 星期六 L System.Logging.ScheduleService[0] #1
      Schedule hosted service is preloading......
info: 2022-12-03 23:16:46.6987703 +08:00 星期六 L System.Logging.ScheduleService[0] #1
      The <job1_trigger1> trigger for scheduler of <job1> successfully appended to the schedule.
info: 2022-12-03 23:16:46.7003295 +08:00 星期六 L System.Logging.ScheduleService[0] #1
      The scheduler of <job1> successfully appended to the schedule.
warn: 2022-12-03 23:16:46.7248216 +08:00 星期六 L System.Logging.ScheduleService[0] #1
      Schedule hosted service preload completed, and a total of <1> schedulers are appended.
info: 2022-12-03 23:16:51.7013640 +08:00 星期六 L MyJob[0] #8
      count: 0 <job1> [C] <job1 job1_trigger1> 5s 1ts 2022-12-03 23:16:51.663 -> 2022-12-03 23:16:56.656
info: 2022-12-03 23:16:56.6768044 +08:00 星期六 L MyJob[0] #9
      count: 1 <job1> [C] <job1 job1_trigger1> 5s 2ts 2022-12-03 23:16:56.656 -> 2022-12-03 23:17:01.635
info: 2022-12-03 23:17:01.6454604 +08:00 星期六 L MyJob[0] #8
      count: 2 <job1> [C] <job1 job1_trigger1> 5s 3ts 2022-12-03 23:17:01.635 -> 2022-12-03 23:17:06.608
info: 2022-12-03 23:17:06.6247917 +08:00 星期六 L MyJob[0] #6
      count: 3 <job1> [C] <job1 job1_trigger1> 5s 4ts 2022-12-03 23:17:06.608 -> 2022-12-03 23:17:11.586
```

作业调度模块为 `JobDetail` 和 `JobBuilder` 提供了多个方法操作额外数据：

```cs showLineNumbers {2,5,8,11,14,17,20,23}
// 查看所有额外数据
var properties = jobDetail.GetProperties();

// 查看单个额外数据，返回 object
var value = jobBuilder.GetProperty("key");

// 查看单个额外数据泛型
var value = jobDetail.GetProperty<int>("key");

// 添加新的额外数据，支持链式操作，如果键已存在，则跳过
jobDetail.AddProperty("key", "Furion").AddProperty("key1", 2);

// 添加或更新额外数据，支持链式操作，不存在则新增，存在则替换，推荐
jobDetail.AddOrUpdateProperty("key", "Furion").AddOrUpdateProperty("key1", 2);

// 还可以通过委托的方式：如果键不存在则插入 count = newValue，否则更新为 value（旧值）+1
jobDetail.AddOrUpdateProperty("count", newValue, value => value + 1);

// 删除某个额外数据，支持链式操作，如果 key 不存在则跳过
jobDetail.RemoveProperty("key").RemoveProperty("key1");

// 清空所有额外数据
jobDetail.ClearProperties();
```

:::important 作业额外数据类型支持

作业额外数据每一项的值只支持 `int32`，`string`，`bool`，`null` 或它们组成的数组类型。

:::

### 26.1.3.5 作业信息特性

作业信息特性 `[JobDetail]` 是为了方便运行时或启动时快速创建作业计划构建器而提供的，可在启动时或运行时通过以下方式创建，如：

```cs showLineNumbers {1}
[JobDetail("job1")]
[PeriodSeconds(5, TriggerId = "trigger1")]
public class MyJob : IJob
{
}
```

- **手动扫描并创建作业计划构建器**

```cs showLineNumbers
var schedulerBuilder = typeof(MyJob).ScanToBuilder();
```

- **通过程序集类型扫描批量创建作业计划构建器**

也可以用于作业持久化 `Preload` 初始化时使用：

```cs showLineNumbers {1,4-5,8}
public IEnumerable<SchedulerBuilder> Preload()
{
      // 扫描所有类型并创建
      return App.EffectiveTypes.Where(t => t.IsJobType())
                              .Select(t => t.ScanToBuilder());

      // 还可以更简单~~
      return App.EffectiveTypes.ScanToBuilders();
}
```

---

**作业信息特性还提供了多个属性配置**，如：

- `JobId`：作业信息 Id，`string` 类型
- `GroupName`：作业组名称，`string` 类型
- `Description`：描述信息，`string` 类型
- `Concurrent`：是否采用并行执行，`bool` 类型，如果设置为 `false`，那么使用 `串行` 执行

使用如下：

```cs showLineNumbers {1}
[JobDetail("jobId", Concurrent = false, Description = "这是一段描述")]
public class MyJob : IJob
{
```

### 26.1.3.6 多种格式字符串输出

`JobDetail` 和 `JobBuilder` 都提供了多种将自身转换成特定格式的字符串。

1. **转换成 `JSON` 字符串**

```cs showLineNumbers
var json = jobDetail.ConvertToJSON();
```

字符串打印如下：

```json showLineNumbers
{
  "jobId": "job1",
  "groupName": null,
  "jobType": "Furion.Application.MyJob",
  "assemblyName": "Furion.Application",
  "description": null,
  "concurrent": true,
  "includeAnnotations": false,
  "properties": "{}",
  "updatedTime": "2022-11-18T22:56:47.4149299+08:00"
}
```

2. **转换成 `SQL` 字符串**

```cs showLineNumbers {2,6,9,13,16,20}
// 输出新增 SQL，使用 CamelCase 属性命名
var insertSql = jobDetail.ConvertToSQL("tbName"
      , PersistenceBehavior.Appended
      , NamingConventions.CamelCase);
// 更便捷拓展
var insertSql = jobDetail.ConvertToInsertSQL("tbName", NamingConventions.CamelCase);

// 输出删除 SQL，使用 Pascal 属性命名
var deleteSql = jobDetail.ConvertToSQL("tbName"
      , PersistenceBehavior.Removed
      , NamingConventions.Pascal);
// 更便捷拓展
var deleteSql = jobDetail.ConvertToDeleteSQL("tbName", NamingConventions.Pascal);

// 输出更新 SQL，使用 UnderScoreCase 属性命名
var updateSql = jobDetail.ConvertToSQL("tbName"
      , PersistenceBehavior.Updated
      , NamingConventions.UnderScoreCase);
// 更便捷拓展
var updateSql = jobDetail.ConvertToUpdateSQL("tbName", NamingConventions.UnderScoreCase);
```

字符串打印如下：

```sql showLineNumbers {2,26,30}
-- 新增语句
INSERT INTO tbName(
      [jobId],
      [groupName],
      [jobType],
      [assemblyName],
      [description],
      [concurrent],
      [includeAnnotations],
      [properties],
      [updatedTime]
)
VALUES(
      'job1',
      NULL,
      'ConsoleApp13.MyJob',
      'ConsoleApp13',
      NULL,
      1,
      0,
      '{}',
      '2022/11/18 23:16:18'
);

-- 删除语句
DELETE FROM tbName
WHERE [JobId] = 'job1';

-- 更新语句
UPDATE tbName
SET
      [job_id] = 'job1',
      [group_name] = NULL,
      [job_type] = 'ConsoleApp13.MyJob',
      [assembly_name] = 'ConsoleApp13',
      [description] = NULL,
      [concurrent] = 1,
      [include_annotations] = 0,
      [properties] = '{}',
      [updated_time] = '2022/11/18 23:16:18'
WHERE [job_id] = 'job1';
```

3. **转换成 `Monitor` 字符串**

```cs showLineNumbers
var monitor = jobDetail.ConvertToMonitor();
```

字符串打印如下：

```bash showLineNumbers
┏━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
┣ ConsoleApp13.MyJob
┣
┣ jobId：                     job1
┣ groupName：
┣ jobType：                   Furion.Application.MyJob
┣ assemblyName：              Furion.Application
┣ description：
┣ concurrent：                True
┣ includeAnnotations：        False
┣ properties：                {}
┣ updatedTime：               2022/11/18 23:26:47
┗━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
```

4. **简要字符串输出**

```cs showLineNumbers
var str = jobDetail.ToString();
```

```bash showLineNumbers
<job1> 这是一段描述
```

### 26.1.3.7 自定义 `SQL` 输出配置

:::important 版本说明

以下内容仅限 `Furion 4.8.2 +` 版本使用。

:::

```cs showLineNumbers {1,3,8,13,18}
services.AddSchedule(options =>
{
    options.JobDetail.ConvertToSQL = (tableName, columnNames, jobDetail, behavior, naming) =>
    {
      // 生成新增 SQL
      if (behavior == PersistenceBehavior.Appended)
      {
            return jobDetail.ConvertToInsertSQL(tableName, naming);
      }
      // 生成更新 SQL
      else if (behavior == PersistenceBehavior.Updated)
      {
            return jobDetail.ConvertToUpdateSQL(tableName, naming);
      }
      // 生成删除 SQL
      else if (behavior == PersistenceBehavior.Removed)
      {
            return jobDetail.ConvertToDeleteSQL(tableName, naming);
      }

      return string.Empty;
    };
});
```

- `ConvertToSQL` 委托参数说明
  - `tableName`：数据库表名称，`string` 类型
  - `columnNames`：数据库列名：`string[]` 类型，只能通过 `索引` 获取
  - `jobDetail`：作业信息 `JobDetail` 对象
  - `behavior`：持久化 `PersistenceBehavior` 类型，用于标记新增，更新还是删除操作
  - `naming`：命名法 `NamingConventions` 类型，包含 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 和 `UnderScoreCase（下划线命名法）`

:::important 注意事项

如果在该委托方法中调用 `jobDetail.ConvertToSQL(..)` 方法会导致死循环。

:::

## 26.1.4 作业处理程序 `IJob`

作业处理程序是作业具体执行的业务逻辑代码，通常由程序员编写，作业处理程序必须实现 `IJob` 接口。

### 26.1.4.1 如何定义

```cs showLineNumbers {1,3,5}
public class MyJob : IJob
{
    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        // your code...
    }
}
```

### 26.1.4.2 依赖注入

实现 `IJob` 的作业处理程序类型默认注册为 `单例`，**那么只要是单例的服务，皆可以通过构造函数注入**，如：`ILogger<>`，`IConfiguration`。

```cs showLineNumbers {3-4,6-7}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    private readonly IConfiguration _configuration;

    public MyJob(ILogger<MyJob> logger
        , IConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger} {count}");

        await Task.CompletedTask;
    }
}
```

- **如果是非单例的接口，如瞬时或范围服务，可通过 `IServiceProvder` 创建**

```cs showLineNumbers {5,9,18-19}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    private readonly IConfiguration _configuration;
    private readonly IServiceProvider _serviceProvider;

    public MyJob(ILogger<MyJob> logger
        , IConfiguration configuration
        , IServiceProvider serviceProvider)
    {
        _logger = logger;
        _configuration = configuration;
        _serviceProvider = serviceProvider;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        using var serviceScope = _serviceProvider.CreateScope();
        var repository = serviceScope.ServiceProvider.GetService<IRepository<User>>();

        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");

        await Task.CompletedTask;
    }
}
```

- **针对高频定时任务，比如每秒执行一次，或者更频繁的任务**

为了避免频繁创建作用域和销毁作用域，可创建长范围的作用域。

```cs showLineNumbers {1,5,13,18,25,27}
public class MyJob : IJob, IDisposable
{
    private readonly ILogger<MyJob> _logger;
    private readonly IConfiguration _configuration;
    private readonly IServiceScope _serviceScope;

    public MyJob(ILogger<MyJob> logger
        , IConfiguration configuration
        , IServiceProvider serviceProvider)
    {
        _logger = logger;
        _configuration = configuration;
        _serviceScope = serviceProvider.CreateScope();
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var repository = _serviceScope.ServiceProvider.GetService<IRepository<User>>();

        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");

        await Task.CompletedTask;
    }

    public void Dispose()
    {
        _serviceScope?.Dispose();
    }
}
```

### 26.1.4.3 `JobExecutingContext` 上下文

`JobExecutingContext` 上下文作为 `ExecuteAsync` 方法的第一个参数，提供了以下几个运行时信息：

- **`JobExecutingContext` 属性列表**
  - `JobId`：作业 `Id`
  - `TriggerId`：当前触发器 `Id`
  - `JobDetail`：作业信息
  - `Trigger`：作业触发器
  - `OccurrenceTime`：调度器检查时间，最准确的记录时间
  - `ExecutingTime`：实际执行时间（可能存在误差）
- **`JobExecutingContext` 方法列表**
  - `.ConvertToJSON(naming)`：将作业计划转换成 `JSON` 字符串
  - `.ToString()`：输出为字符串

### 26.1.4.4 作业被取消处理

一般情况下，作业被临时暂停或取消，但作业处理程序还未处理完成，这个时候我们可以选择取消还是继续执行，如果选择同步取消：

```cs showLineNumbers {1,13,18}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;

    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
       // 创建任务关联取消 Token
        using var cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);

        try
        {
            // 传递给异步服务
            await todo.SomeMethodAsync(cancellationTokenSource.Token);
        }
        catch (Exception ex)
        {
            // ...
        }

        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
    }
}
```

这样当作业被取消时，`SomeMethodAsync` 也会同步取消。

### 26.1.4.5 使用 `Roslyn/Natasha` 动态创建

按照程序开发的正常思维，理应先在代码中创建作业处理程序类型，但我们可以借助 `Roslyn` 动态编译 `C#` 代码。

1. **编辑启动项目 `.csproj` 文件，添加 `<PreserveCompilationContext>true</PreserveCompilationContext>`**

```xml showLineNumbers {3}
<PropertyGroup>
      <TargetFramework>net7.0</TargetFramework>
      <PreserveCompilationContext>true</PreserveCompilationContext>
</PropertyGroup>
```

2. **安装 `DotNetCore.Natasha.CSharp` 拓展包**

[DotNetCore.Natasha.CSharp](https://github.com/dotnetcore/Natasha) 是国人基于 `Roslyn` 开发的非常强大的动态编译 `C#` 库。

```bash showLineNumbers
dotnet add package DotNetCore.Natasha.CSharp
```

3. **根据字符串创建 `IJob` 类型**

```cs showLineNumbers {2,4,9-31,35}
// 初始化
NatashaInitializer.Preheating();
// 创建程序集（可自定义编写程序集名称）
var oop = new AssemblyCSharpBuilder("JobAssembly");
oop.Domain = DomainManagement.Random();

// 添加代码
oop.Add(@"
using Furion.Schedule;
using Microsoft.Extensions.Logging;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace YourProject;

public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;

    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($""{context.JobDetail} {context.Trigger} {context.OccurrenceTime} {context.JobDetail.AssemblyName} {context.JobDetail.JobType}"");
        await Task.CompletedTask;
    }
}
");

// 生成运行时 MyJob 类型
var jobType = oop.GetTypeFromShortName("MyJob");
```

4. **注册作业**

```cs showLineNumbers {4,9}
// 可以在启动的时候添加
services.AddSchedule(options =>
{
      options.AddJob(JobBuilder.Create(jobType)
            , Triggers.PeriodSeconds(5));
});

// 也可以完全在运行时添加（常用）
_schedulerFactory.AddJob(JobBuilder.Create(jobType)
            , Triggers.PeriodSeconds(5));
```

查看作业执行日志：

```bash showLineNumbers {12,14,16,18}
info: 2022-11-25 13:45:49.0150463 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule Hosted Service is running.
info: 2022-11-25 13:45:49.0208313 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule Hosted Service is preloading.
info: 2022-11-25 13:45:49.0406977 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      The Scheduler of <job1> successfully added to the schedule.
warn: 2022-11-25 13:45:49.0803822 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule Hosted Service cancels hibernation and GC.Collect().
info: 2022-11-25 13:45:49.0969060 +08:00 星期五 L System.Logging.ScheduleService[0] #1
      Schedule Hosted Service preload completed, and a total of <1> schedulers are added.
info: 2022-11-25 13:45:54.0695285 +08:00 星期五 L YourProject.MyJob[0] #13
      <job1>  <job1 job1_trigger1>  5000ms 2022/11/25 13:45:54 JobAssembly YourProject.MyJob
info: 2022-11-25 13:45:59.0700268 +08:00 星期五 L YourProject.MyJob[0] #12
      <job1>  <job1 job1_trigger1>  5000ms 2022/11/25 13:45:59 JobAssembly YourProject.MyJob
info: 2022-11-25 13:46:04.0854646 +08:00 星期五 L YourProject.MyJob[0] #11
      <job1>  <job1 job1_trigger1>  5000ms 2022/11/25 13:46:04 JobAssembly YourProject.MyJob
info: 2022-11-25 13:46:09.0924123 +08:00 星期五 L YourProject.MyJob[0] #9
      <job1>  <job1 job1_trigger1>  5000ms 2022/11/25 13:46:09 JobAssembly YourProject.MyJob
```

**惊不惊喜，意外意外~**。

:::tip 小知识

通过 `Roslyn` 的方式支持创建 `IJob`，`JobDetail`，`Trigger`，`Scheduler` 哦，自行测试。😊

:::

## 26.1.5 作业触发器 `Trigger` 及构建器

### 26.1.5.1 关于作业触发器

框架提供了 `Trigger` 类型来描述作业具体的触发时间，`Trigger` 类型提供以下**只读属性**：

| 属性名              | 属性类型        | 默认值  | 说明                                                                 |
| ------------------- | --------------- | ------- | -------------------------------------------------------------------- |
| `TriggerId`         | `string`        |         | 作业触发器 `Id`                                                      |
| `JobId`             | `string`        |         | 作业 `Id`                                                            |
| `TriggerType`       | `string`        |         | 作业触发器类型，存储的是类型的 `FullName`                            |
| `AssemblyName`      | `string`        |         | 作业触发器类型所在程序集，存储的是程序集 `Name`                      |
| `Args`              | `string`        |         | 作业触发器参数，运行时将反序列化为 `object[]` 类型并作为构造函数参数 |
| `Description`       | `string`        |         | 描述信息                                                             |
| `Status`            | `TriggerStatus` | `Ready` | 作业触发器状态                                                       |
| `StartTime`         | `DateTime?`     |         | 起始时间                                                             |
| `EndTime`           | `DateTime?`     |         | 结束时间                                                             |
| `LastRunTime`       | `DateTime?`     |         | 最近运行时间                                                         |
| `NextRunTime`       | `DateTime?`     |         | 下一次运行时间                                                       |
| `NumberOfRuns`      | `long`          | `0`     | 触发次数                                                             |
| `MaxNumberOfRuns`   | `long`          | `0`     | 最大触发次数，`0`：不限制，`n`：N 次                                 |
| `NumberOfErrors`    | `long`          | `0`     | 出错次数                                                             |
| `MaxNumberOfErrors` | `long`          | `0`     | 最大出错次数，`0`：不限制，`n`：N 次                                 |
| `NumRetries`        | `int`           | `0`     | 重试次数                                                             |
| `RetryTimeout`      | `int`           | `1000`  | 重试间隔时间，毫秒单位                                               |
| `StartNow`          | `bool`          | `true`  | 是否立即启动                                                         |
| `RunOnStart`        | `bool`          | `false` | 是否启动时执行一次                                                   |
| `ResetOnlyOnce`     | `bool`          | `true`  | 是否在启动时重置最大触发次数等于一次的作业                           |
| `UpdatedTime`       | `DateTime?`     |         | 作业触发器更新时间                                                   |

### 26.1.5.2 作业触发器状态

作业触发器状态指示了当前作业触发器的状态，使用 `TriggerStatus` 枚举类型（`uint`），该类型包含以下枚举成员。

| 枚举名         | 枚举值 | 说明                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| `Backlog`      | `0`    | 积压，起始时间大于当前时间                                   |
| `Ready`        | `1`    | 就绪                                                         |
| `Running`      | `2`    | 正在运行                                                     |
| `Pause`        | `3`    | 暂停                                                         |
| `Blocked`      | `4`    | 阻塞，本该执行但是没有执行                                   |
| `ErrorToReady` | `5`    | 由失败进入就绪，运行错误当并未超出最大错误数，进入下一轮就绪 |
| `Archived`     | `6`    | 归档，结束时间小于当前时间                                   |
| `Panic`        | `7`    | 崩溃，错误次数超出了最大错误数                               |
| `Overrun`      | `8`    | 超限，运行次数超出了最大限制                                 |
| `Unoccupied`   | `9`    | 无触发时间，下一次执行时间为 `null`                          |
| `NotStart`     | `10`   | 未启动                                                       |
| `Unknown`      | `11`   | 未知作业触发器，作业触发器运行时类型为 `null`                |
| `Unhandled`    | `12`   | 未知作业处理程序，作业处理程序类型运行时类型为 `null`        |

### 26.1.5.3 关于作业触发器构建器

作业触发器 `Trigger` 是作业调度模块提供运行时的**只读类型**，那么我们该如何创建或变更 `Trigger` 对象呢？

`TriggerBuilder` 是作业调度模块提供可用来生成运行时 `Trigger` 的类型，这样做的好处可避免外部直接修改运行时 `Trigger` 数据，还能实现任何修改动作监听，也能避免多线程抢占情况。

作业调度模块提供了多种方式用来创建 `TriggerBuilder` 对象。

1. **通过 `Create` 静态方法创建**

```cs showLineNumbers {2,5,8}
// 根据 Trigger 派生类类型创建
var triggerBuilder = TriggerBuilder.Create<PeriodTrigger>();

// 根据 Type 类型创建
var triggerBuilder = TriggerBuilder.Create(typeof(PeriodTrigger));

// 根据程序集名称和类型完全限定名（FullName）创建
var triggerBuilder = TriggerBuilder.Create("Furion", "Furion.Schedule.PeriodTrigger");
```

2. **通过 `Trigger` 类型创建**

这种方式常用于在运行时更新作业触发器。

```cs showLineNumbers
var triggerBuilder = TriggerBuilder.From(trigger);

//也可以通过以下方式
var triggerBuilder = trigger.GetBuilder();
```

3. **通过 `JSON` 字符串创建**

该方式非常灵活，可从配置文件，`JSON` 字符串，或其他能够返回 `JSON` 字符串的地方创建。

```cs showLineNumbers {2-24}
var triggerBuilder = TriggerBuilder.From(@"
{
    ""triggerId"": ""job1_trigger1"",
    ""triggerType"": ""Furion.Schedule.PeriodSecondsTrigger"",
    ""assemblyName"": ""Furion"",
    ""args"": ""[5]"",
    ""description"": null,
    ""status"": 2,
    ""startTime"": null,
    ""endTime"": null,
    ""lastRunTime"": ""2022-11-20T18:31:56.6859410+08:00"",
    ""nextRunTime"": ""2022-11-20T18:32:01.7233546+08:00"",
    ""numberOfRuns"": 1,
    ""maxNumberOfRuns"": 0,
    ""numberOfErrors"": 0,
    ""maxNumberOfErrors"": 0,
    ""numRetries"": 0,
    ""retryTimeout"": 1000,
    ""startNow"": true,
    ""runOnStart"": false,
    ""resetOnlyOnce"": true,
    ""updatedTime"": ""2022-11-20T18:31:56.7233630+08:00""
}");
```

如果使用的是 `.NET7`，可使用 `"""` 避免转义，如：

```cs showLineNumbers {2-24}
var triggerBuilder = TriggerBuilder.From("""
{
    "triggerId": "job1_trigger1",
    "triggerType": "Furion.Schedule.PeriodSecondsTrigger",
    "assemblyName": "Furion",
    "args": "[5]",
    "description": null,
    "status": 2,
    "startTime": null,
    "endTime": null,
    "lastRunTime": "2022-11-20T18:31:56.6859410+08:00",
    "nextRunTime": "2022-11-20T18:32:01.7233546+08:00",
    "numberOfRuns": 1,
    "maxNumberOfRuns": 0,
    "numberOfErrors": 0,
    "maxNumberOfErrors": 0,
    "numRetries": 0,
    "retryTimeout": 1000,
    "startNow": true,
    "runOnStart": false,
    "resetOnlyOnce": true,
    "updatedTime": "2022-11-20T18:31:56.7233630+08:00"
}
""");
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 命名方式。

**不支持 `UnderScoreCase（下划线命名法）`** ，如 `"include_annotations": true`

:::

4. **还可以通过 `Clone` 静态方法从一个 `TriggerBuilder` 创建**

```cs showLineNumbers
var triggerBuilder = TriggerBuilder.Clone(fromTriggerBuilder);
```

:::important 克隆说明

克隆操作只会克隆 `AssemblyName`，`TriggerType`，`Args`，`Description`，`StartTime`，`EndTime`，`MaxNumberOfRuns`，`MaxNumberOfErrors`，`NumRetries`，`RetryTimeout`，`StartNow`，`RunOnStart`，`ResetOnlyOnce`。

**不会克隆 `TriggerId`，`JobId`，`Status`，`LastRunTime`，`NextRunTime`，`NumberOfRuns`，`NumberOfErrors`，`UpdatedTime`。**

:::

5. **还可以通过 `LoadFrom` 实例方法填充当前的 `TriggerBuilder`**

比如可以传递匿名类型，类类型：

```cs showLineNumbers {2,9,14}
// 会覆盖所有相同的值
triggerBuilder.LoadFrom(new
{
      Description = "我是描述",
      StartTime = DateTime.Now
});

// 支持多个填充，还可以配置跳过 null 值覆盖
triggerBuilder.LoadFrom(new
{
      Description = "我是另外一个描述",
      StartTime = DateTime.Now,
      LastRunTime = default(DateTime?)      // 会跳过赋值
}, ignoreNullValue: true);
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 和 `UnderScoreCase（下划线命名法）` 命名方式。

:::

### 26.1.5.4 内置作业触发器构建器

为了方便快速实现作业触发器，作业调度模块内置了 `Period（间隔）` 和 `Cron（表达式）` 作业触发器，可通过 `TriggerBuilder` 类型或 `Triggers` 静态类创建。

- **`TriggerBuilder` 方式**

```c showLineNumbers {2,5,8,11,13}
// 创建毫秒周期（间隔）作业触发器构建器
var triggerBuilder = TriggerBuilder.Period(5000);

// 创建秒周期（间隔）作业触发器构建器
var triggerBuilder = TriggerBuilder.PeriodSeconds(5);

// 创建分钟周期（间隔）作业触发器构建器
var triggerBuilder = TriggerBuilder.PeriodMinutes(5);

// 创建 Cron 表达式作业触发器构建器
var triggerBuilder = TriggerBuilder.Cron("* * * * *", CronStringFormat.Default);

// 创建 Cron 表达式 Macro 作业触发器构建器
var triggerBuilder = TriggerBuilder.MacroAt("@secondly", 1, 3, 5);
```

- **`Triggers` 方式，推荐**

`Triggers` 具备 `TriggerBuilder` 所有的静态方法，另外还添加了不少更加便捷的静态方法。

```cs showLineNumbers {1-26,28-71}
// 创建毫秒周期（间隔）作业触发器构建器
var triggerBuilder = Triggers.Period(5000);
// 创建秒周期（间隔）作业触发器构建器
var triggerBuilder = Triggers.PeriodSeconds(5);
// 创建分钟周期（间隔）作业触发器构建器
var triggerBuilder = Triggers.PeriodMinutes(5);
// 创建 Cron 表达式作业触发器构建器
var triggerBuilder = Triggers.Cron("* * * * *", CronStringFormat.Default);
// 创建 Cron 表达式 Macro 作业触发器构建器
var triggerBuilder = Triggers.MacroAt("@secondly", 1, 3, 5);
// 创建每秒开始作业触发器构建器
var triggerBuilder = Triggers.Secondly();
// 创建每分钟开始作业触发器构建器
var triggerBuilder = Triggers.Minutely();
// 创建每小时开始作业触发器构建器
var triggerBuilder = Triggers.Hourly();
// 创建每天（午夜）开始作业触发器构建器
var triggerBuilder = Triggers.Daily();
// 创建每月1号（午夜）开始作业触发器构建器
var triggerBuilder = Triggers.Monthly();
// 创建每周日（午夜）开始作业触发器构建器
var triggerBuilder = Triggers.Weekly();
// 创建每年1月1号（午夜）开始作业触发器构建器
var triggerBuilder = Triggers.Yearly();
// 创建每周一至周五（午夜）开始作业触发器构建器
var triggerBuilder = Triggers.Workday();

// Furion 4.8.2.5+ 更多 Macro At
// 每第 3 秒
var triggerBuilder = Triggers.SecondlyAt(3);
// 每第 3，5，6 秒
var triggerBuilder = Triggers.SecondlyAt(3, 5, 6);

// 每分钟第 3 秒
var triggerBuilder = Triggers.MinutelyAt(3);
// 每分钟第 3，5，6 秒
var triggerBuilder = Triggers.MinutelyAt(3, 5, 6);

// 每小时第 3 分钟
var triggerBuilder = Triggers.HourlyAt(3);
// 每小时第 3，5，6 分钟
var triggerBuilder = Triggers.HourlyAt(3, 5, 6);

// 每天第 3 小时正（点）
var triggerBuilder = Triggers.DailyAt(3);
// 每天第 3，5，6 小时正（点）
var triggerBuilder = Triggers.DailyAt(3, 5, 6);

// 每月第 3 天零点正
var triggerBuilder = Triggers.MonthlyAt(3);
// 每月第 3，5，6 天零点正
var triggerBuilder = Triggers.MonthlyAt(3, 5, 6);

// 每周星期 3 零点正
var triggerBuilder = Triggers.WeeklyAt(3);
var triggerBuilder = Triggers.WeeklyAt("WED");  // SUN（星期天），MON，TUE，WED，THU，FRI，SAT
// 每周星期 3，5，6 零点正
var triggerBuilder = Triggers.WeeklyAt(3, 5, 6);
var triggerBuilder = Triggers.WeeklyAt("WED", "FRI", "SAT");
// 还支持混合
var triggerBuilder = Triggers.WeeklyAt(3, "FRI", 6);

// 每年第 3 月 1 日零点正
var triggerBuilder = Triggers.YearlyAt(3);
var triggerBuilder = Triggers.YearlyAt("MAR");  // JAN（一月），FEB，MAR，APR，MAY，JUN，JUL，AUG，SEP，OCT，NOV，DEC
// 每年第 3，5，6 月 1 日零点正
var triggerBuilder = Triggers.YearlyAt(3);
var triggerBuilder = Triggers.YearlyAt(3, 5, 6);
var triggerBuilder = Triggers.YearlyAt("MAR", "MAY", "JUN");
// 还支持混合
var triggerBuilder = Triggers.YearlyAt(3, "MAY", 6);
```

### 26.1.5.5 自定义作业触发器

除了使用作业调度模块提供了 `PeriodTrigger` 和 `CronTrigger` 以外，可自定义作业触发器，只需要继承 `Trigger` 并重写 `GetNextOccurrence` 方法即可，如实现一个间隔两秒的作业触发器。

```cs showLineNumbers {1,3,5}
public class TwiceSecondTrigger : Trigger
{
    public override DateTime GetNextOccurrence(DateTime startAt)
    {
        return startAt.AddSeconds(2);
    }
}
```

之后可通过 `Triggers.Create` 或 `Triggers.Create` 创建即可：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(Triggers.Create<TwiceSecondTrigger>());
});
```

查看作业执行结果：

```bash showLineNumbers {2,4,6,8,10,12}
info: 2022-11-20 21:13:02.4726416 +08:00 星期日 L ConsoleApp13.MyJob[0] #9
      job1 job1_trigger1 2022/11/20 21:13:02 ConsoleApp13.TwiceSecondTrigger
info: 2022-11-20 21:13:04.4591328 +08:00 星期日 L ConsoleApp13.MyJob[0] #6
      job1 job1_trigger1 2022/11/20 21:13:04 ConsoleApp13.TwiceSecondTrigger
info: 2022-11-20 21:13:06.4677716 +08:00 星期日 L ConsoleApp13.MyJob[0] #4
      job1 job1_trigger1 2022/11/20 21:13:06 ConsoleApp13.TwiceSecondTrigger
info: 2022-11-20 21:13:08.4726987 +08:00 星期日 L ConsoleApp13.MyJob[0] #14
      job1 job1_trigger1 2022/11/20 21:13:08 ConsoleApp13.TwiceSecondTrigger
info: 2022-11-20 21:13:10.4827028 +08:00 星期日 L ConsoleApp13.MyJob[0] #9
      job1 job1_trigger1 2022/11/20 21:13:10 ConsoleApp13.TwiceSecondTrigger
info: 2022-11-20 21:13:12.4936247 +08:00 星期日 L ConsoleApp13.MyJob[0] #14
      job1 job1_trigger1 2022/11/20 21:13:12 ConsoleApp13.TwiceSecondTrigger
```

另外，自定义作业触发器还支持传递参数：

:::important 参数特别说明

如果自定义作业触发器包含参数，那么**必须满足以下两个条件**：

- **参数必须通过唯一的构造函数传入，有且最多只能拥有一个构造函数**
- **参数的类型只能是 `int`，`string`，`bool`，`null` 或由它们组成的数组类型**

:::

```cs showLineNumbers {1,3,5,8,12}
public class SomeSecondTrigger : Trigger
{
    public SomeSecondTrigger(int seconds) // 支持多个参数
    {
        Seconds = seconds;
    }

    private int Seconds { get; }

    public override DateTime GetNextOccurrence(DateTime startAt)
    {
        return startAt.AddSeconds(Seconds);
    }
}
```

之后可通过 `Triggers.Create` 或 `Triggers.Create` 创建并传入参数。

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(Triggers.Create<SomeSecondTrigger>(3)); // 3 秒执行一次
});
```

查看作业执行结果：

```bash showLineNumbers {2,4,6,8,10,12}
info: 2022-11-20 21:33:46.3074692 +08:00 星期日 L ConsoleApp13.MyJob[0] #4
      job1 job1_trigger1 2022/11/20 21:33:46 ConsoleApp13.SomeSecondTrigger
info: 2022-11-20 21:33:49.3101667 +08:00 星期日 L ConsoleApp13.MyJob[0] #6
      job1 job1_trigger1 2022/11/20 21:33:49 ConsoleApp13.SomeSecondTrigger
info: 2022-11-20 21:33:52.3222046 +08:00 星期日 L ConsoleApp13.MyJob[0] #8
      job1 job1_trigger1 2022/11/20 21:33:52 ConsoleApp13.SomeSecondTrigger
info: 2022-11-20 21:33:55.3270737 +08:00 星期日 L ConsoleApp13.MyJob[0] #4
      job1 job1_trigger1 2022/11/20 21:33:55 ConsoleApp13.SomeSecondTrigger
info: 2022-11-20 21:33:58.3293727 +08:00 星期日 L ConsoleApp13.MyJob[0] #6
      job1 job1_trigger1 2022/11/20 21:33:58 ConsoleApp13.SomeSecondTrigger
info: 2022-11-20 21:34:01.3472296 +08:00 星期日 L ConsoleApp13.MyJob[0] #4
      job1 job1_trigger1 2022/11/20 21:34:01 ConsoleApp13.SomeSecondTrigger
```

自定义作业触发器除了可重写 `GetNextOccurrence` 方法之后，还提供了 `ShouldRun` 和 `ToString` 方法可重写，如：

```cs showLineNumbers {15,22,24}
public class SomeSecondTrigger : Trigger
{
    public SomeSecondTrigger(int seconds)
    {
        Seconds = seconds;
    }

    private int Seconds { get; }

    public override DateTime GetNextOccurrence(DateTime startAt)
    {
        return startAt.AddSeconds(Seconds);
    }

    public override bool ShouldRun(JobDetail jobDetail, DateTime startAt)
    {
        // 在这里进一步控制，如果返回 false，则作业触发器跳过执行

        return base.ShouldRun(jobDetail, startAt);
    }

    public override string ToString()
    {
        return $"自定义递增 {Seconds}s 触发器";
    }
}
```

推荐重写 `GetNextRunTime` 和 `ToString` 方法即可，如果重写了 `ToString` 方法，那么可以通过 $`{trigger}` 输出，如：

```cs showLineNumbers {11}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.CompletedTask;
    }
}
```

查看作业执行结果：

```bash showLineNumbers {2,4}
info: 2022-11-20 21:43:07.4570694 +08:00 星期日 L ConsoleApp13.MyJob[0] #4
      job1 job1_trigger1 2022/11/20 21:43:07 自定义递增 3s 触发器
info: 2022-11-20 21:43:10.4629078 +08:00 星期日 L ConsoleApp13.MyJob[0] #9
      job1 job1_trigger1 2022/11/20 21:43:10 自定义递增 3s 触发器
```

### 26.1.5.6 作业触发器特性

如果 `JobBuilder` 配置了 `IncludeAnnotations` 参数且为 `true`，那么将会自动解析 `IJob` 的实现类型的所有继承 `TriggerAttribute` 的特性，目前作业调度模块内置了以下作业触发器特性：

- `[Period(5000)]`：毫秒周期（间隔）作业触发器特性
- `[PeriodSeconds(5)]`：秒周期（间隔）作业触发器特性
- `[PeriodMinutes(5)]`：分钟周期（间隔）作业触发器特性
- `[Cron("* * * * *", CronStringFormat.Default)]`：Cron 表达式作业触发器特性
- `[MacroAt("@secondly", 1, 3, 5)]`：Cron 表达式 Macro 作业触发器特性
- `[Secondly]`：每秒开始作业触发器特性
- `[Minutely]`：每分钟开始作业触发器特性
- `[Hourly]`：每小时开始作业触发器特性
- `[Daily]`：每天（午夜）开始作业触发器特性
- `[Monthly]`：每月 1 号（午夜）开始作业触发器特性
- `[Weekly]`：每周日（午夜）开始作业触发器特性
- `[Yearly]`：每年 1 月 1 号（午夜）开始作业触发器特性
- `[Workday]`：每周一至周五（午夜）开始触发器特性
- `[SecondlyAt]`：特定秒开始作业触发器特性
- `[MinutelyAt]`：每分钟特定秒开始作业触发器特性
- `[HourlyAt]`：每小时特定分钟开始作业触发器特性
- `[DailyAt]`：每天特定小时开始作业触发器特性
- `[MonthlyAt]`：每月特定天（午夜）开始作业触发器特性
- `[WeeklyAt]`：每周特定星期几（午夜）开始作业触发器特性
- `[YearlyAt]`：每年特定月 1 号（午夜）开始作业触发器特性

使用如下：

```cs showLineNumbers {3,6}
services.AddSchedule(options =>
{
    options.AddJob(JobBuilder.Create<MyJob>().SetIncludeAnnotations(true));

    // 也支持自定义配置 + 特性扫描
    options.AddJob(JobBuilder.Create<MyJob>().SetIncludeAnnotations(true)
                  , Triggers.PeriodSeconds(5));
});
```

```cs showLineNumbers {1-3}
[Minutely]
[PeriodSeconds(5)]
[Cron("* * * * *")]
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.CompletedTask;
    }
}
```

查看作业执行结果：

```bash showLineNumbers {2,4,6,8,10}
info: 2022-11-20 22:10:54.5027217 +08:00 星期日 L ConsoleApp13.MyJob[0] #9
      job1 job1_trigger2 2022/11/20 22:10:54  5000ms
info: 2022-11-20 22:10:59.4948832 +08:00 星期日 L ConsoleApp13.MyJob[0] #9
      job1 job1_trigger2 2022/11/20 22:10:59  5000ms
info: 2022-11-20 22:11:00.0353681 +08:00 星期日 L ConsoleApp13.MyJob[0] #6
      job1 job1_trigger3 2022/11/20 22:11:00  * * * * *
info: 2022-11-20 22:11:00.0372492 +08:00 星期日 L ConsoleApp13.MyJob[0] #8
      job1 job1_trigger1 2022/11/20 22:11:00  * * * * *
info: 2022-11-20 22:11:04.5094807 +08:00 星期日 L ConsoleApp13.MyJob[0] #8
      job1 job1_trigger2 2022/11/20 22:11:04  5000ms
```

---

**除了使用内置特性，我们还可以自定义作业触发器特性**，如：

```cs showLineNumbers {1,2,5}
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class SomeSecondAttribute : TriggerAttribute
{
    public SomeSecondAttribute(int seconds)
        : base(typeof(SomeSecondTrigger), seconds)
    {
    }
}
```

使用如下：

```cs showLineNumbers {1}
[SomeSecond(3)]
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.CompletedTask;
    }
}
```

查看作业执行结果：

```bash showLineNumbers {2,4,6,8,10}
info: 2022-11-20 22:16:22.0933295 +08:00 星期日 L ConsoleApp13.MyJob[0] #9
      job1 job1_trigger1 2022/11/20 22:16:22 自定义递增 3s 触发器
info: 2022-11-20 22:16:25.0823563 +08:00 星期日 L ConsoleApp13.MyJob[0] #8
      job1 job1_trigger1 2022/11/20 22:16:25 自定义递增 3s 触发器
info: 2022-11-20 22:16:28.0910993 +08:00 星期日 L ConsoleApp13.MyJob[0] #6
      job1 job1_trigger1 2022/11/20 22:16:28 自定义递增 3s 触发器
info: 2022-11-20 22:16:31.0937955 +08:00 星期日 L ConsoleApp13.MyJob[0] #9
      job1 job1_trigger1 2022/11/20 22:16:31 自定义递增 3s 触发器
info: 2022-11-20 22:16:34.1034905 +08:00 星期日 L ConsoleApp13.MyJob[0] #6
      job1 job1_trigger1 2022/11/20 22:16:34 自定义递增 3s 触发器
```

---

**作业触发器特性还提供了多个属性配置**，如：

- `TriggerId`：作业触发器 Id，`string` 类型
- `Description`：描述信息，`string` 类型
- `StartTime`：起始时间，`string` 类型
- `EndTime`：结束时间，`string` 类型
- `MaxNumberOfRuns`：最大触发次数，`long` 类型，`0`：不限制；`n`：N 次
- `MaxNumberOfErrors`：最大出错次数，`long` 类型，`0`：不限制；`n`：N 次
- `NumRetries`：重试次数，`int` 类型，默认值 `0`
- `RetryTimeout`：重试间隔时间，`int` 类型，默认值 `1000`
- `StartNow`：是否立即启动，`bool` 类型，默认值 `true`
- `RunOnStart`：是否启动时执行一次，`bool` 类型，默认值 `false`
- `ResetOnlyOnce`：是否在启动时重置最大触发次数等于一次的作业，`bool` 类型，默认值 `true`

使用如下：

```cs showLineNumbers {1}
[PeriodSeconds(5, TriggerId = "trigger1", Description = "这是一段描述")]
public class MyJob : IJob
{
```

### 26.1.5.7 设置作业触发器构建器

`TriggerBuilder` 提供了和 `Trigger` 完全匹配的 `Set[属性名]` 方法来配置作业触发器各个属性，如：

```cs showLineNumbers {3,27}
 services.AddSchedule(options =>
 {
     var triggerBuilder = Triggers.Period(5000)
         .SetTriggerId("trigger1")   // 作业触发器 Id
         .SetTriggerType("Furion", "Furion.Schedule.PeriodTrigger")  // 作业触发器类型，支持多个重载
         .SetTriggerType<PeriodTrigger>()    // 作业触发器类型，支持多个重载
         .SetTriggerType(typeof(PeriodTrigger))  // 作业触发器类型，支持多个重载
         .SetArgs("[5000]")  // 作业触发器参数，支持多个重载
         .SetArgs(5000)   // 作业触发器参数，支持多个重载
         .SetDescription("作业触发器描述")  // 作业触发器描述
         .SetStatus(TriggerStatus.Ready) // 作业触发器状态
         .SetStartTime(DateTime.Now) // 作业触发器起始时间
         .SetEndTime(DateTime.Now.AddMonths(1)) // 作业触发器结束时间
         .SetLastRunTime(DateTime.Now.AddSeconds(-5))    // 作业触发器最近运行时间
         .SetNextRunTime(DateTime.Now.AddSeconds(5)) // 作业触发器下一次运行时间
         .SetNumberOfRuns(1) // 作业触发器触发次数
         .SetMaxNumberOfRuns(100)    // 作业触发器最大触发器次数
         .SetNumberOfErrors(1)   // 作业触发器出错次数
         .SetMaxNumberOfErrors(100)  // 作业触发器最大出错次数
         .SetNumRetries(3)   // 作业触发器出错重试次数
         .SetRetryTimeout(1000)  // 作业触发器重试间隔时间
         .SetStartNow(true)  // 作业触发器是否立即启动
         .SetRunOnStart(false)    // 作业触发器是否启动时执行一次
         .SetResetOnlyOnce(true)    // 作业触发器是否在启动时重置最大触发次数等于一次的作业
         ;

     options.AddJob<MyJob>(triggerBuilder);
 });
```

### 26.1.5.8 多种格式字符串输出

`Trigger` 和 `TriggerBuilder` 都提供了多种将自身转换成特定格式的字符串。

1. **转换成 `JSON` 字符串**

```cs showLineNumbers
var json = trigger.ConvertToJSON();
```

字符串打印如下：

```json showLineNumbers
{
  "triggerId": "job1_trigger1",
  "jobId": "job1",
  "triggerType": "Furion.Schedule.PeriodSecondsTrigger",
  "assemblyName": "Furion",
  "args": "[5]",
  "description": null,
  "status": 2,
  "startTime": null,
  "endTime": null,
  "lastRunTime": "2022-11-20T22:25:03.8176033+08:00",
  "nextRunTime": "2022-11-20T22:25:08.8385903+08:00",
  "numberOfRuns": 1,
  "maxNumberOfRuns": 0,
  "numberOfErrors": 0,
  "maxNumberOfErrors": 0,
  "numRetries": 0,
  "retryTimeout": 1000,
  "startNow": true,
  "runOnStart": false,
  "resetOnlyOnce": true,
  "updatedTime": "2022-11-20T22:25:03.8386511+08:00"
}
```

2. **转换成 `SQL` 字符串**

```cs showLineNumbers {2,6,9,13,16,20}
// 输出新增 SQL，使用 CamelCase 属性命名
var insertSql = trigger.ConvertToSQL("tbName"
      , PersistenceBehavior.Appended
      , NamingConventions.CamelCase);
// 更便捷拓展
var insertSql = trigger.ConvertToInsertSQL("tbName", NamingConventions.CamelCase);

// 输出删除 SQL，使用 Pascal 属性命名
var deleteSql = trigger.ConvertToSQL("tbName"
      , PersistenceBehavior.Removed
      , NamingConventions.Pascal);
// 更便捷拓展
var deleteSql = trigger.ConvertToDeleteSQL("tbName", NamingConventions.Pascal);

// 输出更新 SQL，使用 UnderScoreCase 属性命名
var updateSql = trigger.ConvertToSQL("tbName"
      , PersistenceBehavior.Updated
      , NamingConventions.UnderScoreCase);
// 更便捷拓展
var updateSql = trigger.ConvertToUpdateSQL("tbName", NamingConventions.UnderScoreCase);
```

字符串打印如下：

```sql showLineNumbers {2,50,54}
-- 新增语句
INSERT INTO tbName(
      [triggerId],
      [jobId],
      [triggerType],
      [assemblyName],
      [args],
      [description],
      [status],
      [startTime],
      [endTime],
      [lastRunTime],
      [nextRunTime],
      [numberOfRuns],
      [maxNumberOfRuns],
      [numberOfErrors],
      [maxNumberOfErrors],
      [numRetries],
      [retryTimeout],
      [startNow],
      [runOnStart],
      [resetOnlyOnce],
      [updatedTime]
)
VALUES(
      'job1_trigger1',
      'job1',
      'Furion.Schedule.PeriodSecondsTrigger',
      'Furion',
      '[5]',
      NULL,
      2,
      NULL,
      NULL,
      '2022/11/20 22:27:47',
      '2022/11/20 22:27:52',
      1,
      0,
      0,
      0,
      0,
      1000,
      1,
      0,
      1,
      '2022/11/20 22:27:47'
);

-- 删除语句
DELETE FROM tbName
WHERE [TriggerId] = 'job1_trigger1' AND [JobId] = 'job1';

-- 更新语句
UPDATE tbName
SET
      [trigger_id] = 'job1_trigger1',
      [job_id] = 'job1',
      [trigger_type] = 'Furion.Schedule.PeriodSecondsTrigger',
      [assembly_name] = 'Furion',
      [args] = '[5]',
      [description] = NULL,
      [status] = 2,
      [start_time] = NULL,
      [end_time] = NULL,
      [last_run_time] = '2022/11/20 22:27:47',
      [next_run_time] = '2022/11/20 22:27:52',
      [number_of_runs] = 1,
      [max_number_of_runs] = 0,
      [number_of_errors] = 0,
      [max_number_of_errors] = 0,
      [num_retries] = 0,
      [retry_timeout] = 1000,
      [start_now] = 1,
      [run_on_start] = 0,
      [reset_only_once] = 1,
      [updated_time] = '2022/11/20 22:27:47'
WHERE [trigger_id] = 'job1_trigger1' AND [job_id] = 'job1';
```

3. **转换成 `Monitor` 字符串**

```cs showLineNumbers
var monitor = trigger.ConvertToMonitor();
```

字符串打印如下：

```bash showLineNumbers
┏━━━━━━━━━━━  Trigger ━━━━━━━━━━━
┣ Furion.Schedule.PeriodSecondsTrigger
┣
┣ triggerId：                job1_trigger1
┣ jobId：                    job1
┣ triggerType：              Furion.Schedule.PeriodSecondsTrigger
┣ assemblyName：             Furion
┣ args：                     [5]
┣ description：
┣ status：                   Running
┣ startTime：
┣ endTime：
┣ lastRunTime：              2022/11/20 22:30:41
┣ nextRunTime：              2022/11/20 22:30:46
┣ numberOfRuns：             1
┣ maxNumberOfRuns：          0
┣ numberOfErrors：           0
┣ maxNumberOfErrors：        0
┣ numRetries：               0
┣ retryTimeout：             1000
┣ startNow：                 True
┣ runOnStart：               False
┣ resetOnlyOnce：            True
┣ updatedTime：              2022/11/20 22:30:41
┗━━━━━━━━━━━  Trigger ━━━━━━━━━━━
```

4. **简要字符串输出**

```cs showLineNumbers
var str = trigger.ToString();
```

```bash showLineNumbers
<job3 job3_trigger1> 这是一段描述
<job2 job2_trigger1> 这是一段描述 * * * * * *
<job1 job1_trigger1> 这是一段描述 5000ms
```

### 26.1.5.9 自定义 `SQL` 输出配置

:::important 版本说明

以下内容仅限 `Furion 4.8.2 +` 版本使用。

:::

```cs showLineNumbers {1,3,8,13,18}
services.AddSchedule(options =>
{
    options.Trigger.ConvertToSQL = (tableName, columnNames, trigger, behavior, naming) =>
    {
      // 生成新增 SQL
      if (behavior == PersistenceBehavior.Appended)
      {
            return trigger.ConvertToInsertSQL(tableName, naming);
      }
      // 生成更新 SQL
      else if (behavior == PersistenceBehavior.Updated)
      {
            return trigger.ConvertToUpdateSQL(tableName, naming);
      }
      // 生成删除 SQL
      else if (behavior == PersistenceBehavior.Removed)
      {
            return trigger.ConvertToDeleteSQL(tableName, naming);
      }

      return string.Empty;
    };
});
```

- `ConvertToSQL` 委托参数说明
  - `tableName`：数据库表名称，`string` 类型
  - `columnNames`：数据库列名：`string[]` 类型，只能通过 `索引` 获取
  - `jobDetail`：作业信息 `Trigger` 对象
  - `behavior`：持久化 `PersistenceBehavior` 类型，用于标记新增，更新还是删除操作
  - `naming`：命名法 `NamingConventions` 类型，包含 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 和 `UnderScoreCase（下划线命名法）`

:::important 注意事项

如果在该委托方法中调用 `trigger.ConvertToSQL(..)` 方法会导致死循环。

:::

## 26.1.6 作业计划 `Scheduler` 及构建器

### 26.1.6.1 关于作业计划

所谓的作业计划（`Scheduler`）是将作业信息(`JobDetail`），作业触发器（`Trigger`）和作业处理程序（`IJob`）关联起来，并添加到作业调度器中等待调度执行。

作为计划（`Scheduler`）类型对外是不公开的，但提供了对应的 `IScheduler` 接口进行操作。

### 26.1.6.2 关于作业计划构建器

作业计划 `Scheduler` 是作业调度模块提供运行时的**只读类型**，那么我们该如何创建或变更 `Scheduler` 对象呢？

`SchedulerBuilder` 是作业调度模块提供可用来生成运行时 `Scheduler` 的类型，这样做的好处可避免外部直接修改运行时 `Scheduler` 数据，还能实现任何修改动作监听，也能避免多线程抢占情况。

作业调度模块提供了多种方式用来创建 `SchedulerBuilder` 对象。

1. **通过 `Create` 静态方法创建**

```cs showLineNumbers {2,9}
// 创建作业计划必须传入 JoBuilder 和 0或1个以上的 TiggerBuilder
var schedulerBuilder = SchedulerBuilder.Create(
            JobBuilder.Create<MyJob>()
            , Triggers.PeriodSeconds(5), Triggers.Minutely());

// 添加到作业调度器中
services.AddSchedule(options =>
{
      options.AddJob(schedulerBuilder);
});
```

2. **通过 `JSON` 字符串创建**

该方式非常灵活，可从配置文件，`JSON` 字符串，或其他能够返回 `JSON` 字符串的地方创建。

```cs showLineNumbers {1,3,14,43}
var schedulerBuilder = SchedulerBuilder.From(@"
{
    ""jobDetail"": {
        ""jobId"": ""job1"",
        ""groupName"": null,
        ""jobType"": ""ConsoleApp32.MyJob"",
        ""assemblyName"": ""ConsoleApp32"",
        ""description"": null,
        ""concurrent"": true,
        ""includeAnnotations"": false,
        ""properties"": ""{}"",
        ""updatedTime"": ""2022-11-17T09:25:47.0471107+08:00""
    },
    ""triggers"": [
        {
            ""triggerId"": ""job1_trigger1"",
            ""triggerType"": ""Furion.Schedule.PeriodSecondsTrigger"",
            ""assemblyName"": ""Furion"",
            ""args"": ""[5]"",
            ""description"": null,
            ""status"": 2,
            ""startTime"": null,
            ""endTime"": null,
            ""lastRunTime"": ""2022-11-20T18:31:56.6859410+08:00"",
            ""nextRunTime"": ""2022-11-20T18:32:01.7233546+08:00"",
            ""numberOfRuns"": 1,
            ""maxNumberOfRuns"": 0,
            ""numberOfErrors"": 0,
            ""maxNumberOfErrors"": 0,
            ""numRetries"": 0,
            ""retryTimeout"": 1000,
            ""startNow"": true,
            ""runOnStart"": false,
            ""resetOnlyOnce"": true,
            ""updatedTime"": ""2022-11-20T18:31:56.7233630+08:00""
        }
    ]
}");

// 添加到作业调度器中
services.AddSchedule(options =>
{
      options.AddJob(schedulerBuilder);
});
```

如果使用的是 `.NET7`，可使用 `"""` 避免转义，如：

```cs showLineNumbers {1,3,14}
var schedulerBuilder = SchedulerBuilder.From("""
{
    "jobDetail": {
        "jobId": "job1",
        "groupName": null,
        "jobType": "Furion.Application.MyJob",
        "assemblyName": "Furion.Application",
        "description": null,
        "concurrent": true,
        "includeAnnotations": false,
        "properties": "{}",
        "updatedTime": "2022-11-17T09:25:47.0471107+08:00"
    },
    "triggers": [
        {
            "triggerId": "job1_trigger1",
            "triggerType": "Furion.Schedule.PeriodSecondsTrigger",
            "assemblyName": "Furion",
            "args": "[5]",
            "description": null,
            "status": 2,
            "startTime": null,
            "endTime": null,
            "lastRunTime": "2022-11-20T18:31:56.6859410+08:00",
            "nextRunTime": "2022-11-20T18:32:01.7233546+08:00",
            "numberOfRuns": 1,
            "maxNumberOfRuns": 0,
            "numberOfErrors": 0,
            "maxNumberOfErrors": 0,
            "numRetries": 0,
            "retryTimeout": 1000,
            "startNow": true,
            "runOnStart": false,
            "resetOnlyOnce": true,
            "updatedTime": "2022-11-20T18:31:56.7233630+08:00"
        }
    ]
}
""");
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 命名方式。

**不支持 `UnderScoreCase（下划线命名法）`** ，如 `"include_annotations": true`

:::

3. **还可以通过 `Clone` 静态方法从一个 `SchedulerBuilder` 创建**

```cs showLineNumbers
var schedulerBuilder = SchedulerBuilder.Clone(fromSchedulerBuilder);
```

:::important 克隆说明

克隆操作将克隆 `JobBuilder` 和 `TriggerBuilders`，同时 `Behavior` 会被标记为 `PersistenceBehavior.Appended`。

:::

### 26.1.6.3 设置作业计划构建器

`Scheduler` 提供了多个方法操作 `JobBuilder` 和 `TriggerBuilder`，如：

```cs showLineNumbers {2,5,8,11,14,16-17,20,22-23,26,28,30-33,36}
// 获取当前的作业信息构建器
var jobBuilder = schedulerBuilder.GetJobBuilder();

// 更新当前作业信息构建器
schedulerBuilder.UpdateJobBuilder(jobBuilder.SetDescription("新的描述"));

// 获取所有的作业触发器构建器集合
var triggerBuilders = schedulerBuilder.GetTriggerBuilders();

// 获取单个作业触发器构建器
var triggerBuilder = schedulerBuilder.GetTriggerBuilder("job1_trigger1");

// 新增作业触发器构建器
schedulerBuilder.AddTriggerBuilder(Triggers.Minutely());
// 也支持链式添加或添加多个
schedulerBuilder.AddTriggerBuilder(Triggers.Minutely()).AddTriggerBuilder(Trigger.Hourly());
schedulerBuilder.AddTriggerBuilders(Trigger.Minutely(), Trigger.Hourly());

// 更新作业触发器构建器
schedulerBuilder.UpdateTriggerBuilder(triggerBuilder.SetDescription("新的触发器描述"));
// 也支持链式更新或更新多个
schedulerBuilder.UpdateTriggerBuilder(triggerBuilder1).UpdateTriggerBuilder(triggerBuilder2);
schedulerBuilder.UpdateTriggerBuilders(triggerBuilder1, triggerBuilder2);

// 删除作业触发器构建器
schedulerBuilder.RemoveTriggerBuilder(triggerBuilder);
// 可以根据作业触发器 Id 删除
schedulerBuilder.RemoveTriggerBuilder("job1_trigger1", out var builder);
// 也支持链式删除或删除多个
schedulerBuilder.RemoveTriggerBuilder(triggerBuilder1).RemoveTriggerBuilder(triggerBuilder2);
schedulerBuilder.RemoveTriggerBuilders(triggerBuilder1, triggerBuilder2);
schedulerBuilder.RemoveTriggerBuilder("job1_trigger1", out var triggerBuilder).RemoveTriggerBuilder("job1_trigger2", out _);
schedulerBuilder.RemoveTriggerBuilder("job1_trigger1", "job1_trigger2");

// 清空所有作业触发器构建器
schedulerBuilder.ClearTriggerBuilders();
```

除了提供上面的 `CURD` 操作以外，还提供了可以更改 `SchedulerBuilder` 的**持久化行为**的方法，如：

```cs showLineNumbers
// 标记当前作业计划构建器为新增状态
schedulerBuilder.Appended();  // 默认值
// 标记当前作业计划构建器为更新状态
schedulerBuilder.Updated();
// 标记当前作业计划构建器为删除状态
schedulerBuilder.Removed();
```

### 26.1.6.4 多种格式字符串输出

`Scheduler` 和 `SchedulerBuilder` 都提供了多种将自身转换成特定格式的字符串。

1. **转换成 `JSON` 字符串**

```cs showLineNumbers
var json = schedulerBuilder.ConvertToJSON();
```

字符串打印如下：

```json showLineNumbers {2,13}
{
  "jobDetail": {
    "jobId": "job1",
    "groupName": null,
    "jobType": "Furion.Application.MyJob",
    "assemblyName": "Furion.Application",
    "description": null,
    "concurrent": true,
    "includeAnnotations": false,
    "properties": "{}",
    "updatedTime": "2022-11-17T09:25:47.0471107+08:00"
  },
  "triggers": [
    {
      "triggerId": "job1_trigger1",
      "jobId": null,
      "triggerType": "Furion.Schedule.PeriodSecondsTrigger",
      "assemblyName": "Furion",
      "args": "[5]",
      "description": null,
      "status": 2,
      "startTime": null,
      "endTime": null,
      "lastRunTime": "2022-11-20T18:31:56.6859410+08:00",
      "nextRunTime": "2022-11-20T18:32:01.7233546+08:00",
      "numberOfRuns": 1,
      "maxNumberOfRuns": 0,
      "numberOfErrors": 0,
      "maxNumberOfErrors": 0,
      "numRetries": 0,
      "retryTimeout": 1000,
      "startNow": true,
      "runOnStart": false,
      "resetOnlyOnce": true,
      "updatedTime": "2022-11-20T18:31:56.7233630+08:00"
    }
  ]
}
```

## 26.1.7 作业调度器 `ScheduleOptionsBuilder` 配置选项

### 26.1.7.1 关于 `ScheduleOptionsBuilder`

`ScheduleOptionsBuilder` 配置选项主要是用来初始化调度作业服务和作业调度器相关配置的。只作为 `services.AddSchedule` 服务注册的配置参数，如：

```cs showLineNumbers {2,8-9}
// 通过委托的方式配置
services.AddSchedule(options =>
{
      // options 类型为 ScheduleOptionsBuilder
});

// 自行创建对象实例方式配置
var scheduleOptionsBuilder = new ScheduleOptionsBuilder();
services.AddSchedule(scheduleOptionsBuilder);
```

### 26.1.7.2 `ScheduleOptionsBuilder` 内置属性和方法

- **内置属性配置**

```cs showLineNumbers {4,7,10,13}
services.AddSchedule(options =>
{
      // 是否使用 UTC 时间，该配置主要用来作为作业调度器检查时间格式的依据
      options.UseUtcTimestamp = false;

      // 是否输出作业调度器日志
      options.LogEnabled = true;

      // 配置输出 SQL 的数据库类型，Furion 4.8.2.3+
      options.BuildSqlType = SqlTypes.SqlServer;

      // 定义未捕获的异常，通常是 Task 异常
      options.UnobservedTaskExceptionHandler = (obj, args) =>
      {
      };
});
```

- **内置方法配置**

```cs showLineNumbers {4-18,21,24,27,30,36}
services.AddSchedule(options =>
{
      // 添加作业
      options.AddJob(schedulerBuilder);
      options.AddJob(schedulerBuilder, schedulerBuilder1, ...); // Furion 4.8.2.4+
      options.AddJob(jobBuilder, triggerBuilder, ...);
      options.AddJob<MyJob>(triggerBuilder, ...);
      options.AddJob<MyJob>("作业 Id", triggerBuilder, ...);
      options.AddJob<MyJob>("作业 Id", concurrent: true, triggerBuilder, ...);
      options.AddJob<MyJob>(concurrent: true, triggerBuilder, ...);
      options.AddJob(typeof(MyJob), triggerBuilder, ...);
      options.AddJob(typeof(MyJob), "作业 Id", triggerBuilder, ...);
      options.AddJob(typeof(MyJob), "作业 Id", concurrent: true, triggerBuilder, ...);
      options.AddJob(typeof(MyJob), concurrent: true, triggerBuilder, ...);
      options.AddJob((s, c, t) => {}, triggerBuilder, ...);
      options.AddJob((s, c, t) => {}, "作业 Id", triggerBuilder, ...);
      options.AddJob((s, c, t) => {}, "作业 Id", concurrent: true, triggerBuilder, ...);
      options.AddJob((s, c, t) => {}, concurrent: true, triggerBuilder, ...);

      // 添加作业执行监视器
      options.AddMonitor<YourJobMonitor>();

      // 添加作业执行器
      options.AddExecutor<YourJobMonitor>();

      // 添加作业持久化器
      options.AddPersistence<YourJobPersistence>();

      // 自定义 JobDetail SQL 输出
      options.JobDetail.ConvertToSQL = (tableName, columnNames, jobDetail, behavior, naming) =>
      {
            // ...
      };

      // 自定义 Trigger SQL 输出
      options.Trigger.ConvertToSQL = (tableName, columnNames, trigger, behavior, naming) =>
      {
            // ...
      };
});
```

## 26.1.8 作业监视器 `IJobMonitor`

调度作业服务提供了 `IJobMonitor` 监视器接口，实现该接口可以监视所有作业处理程序执行事件，包括 `执行之前、执行之后，执行异常`。

如添加 `YourJobMonitor`：

```cs showLineNumbers  {1,9,15}
public class YourJobMonitor : IJobMonitor
{
    private readonly ILogger<YourJobMonitor> _logger;
    public YourJobMonitor(ILogger<YourJobMonitor> logger)
    {
        _logger = logger;
    }

    public Task OnExecutingAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation("执行之前：{JobId} {TriggerId}", context.JobId, context.TriggerId);
        return Task.CompletedTask;
    }

    public Task OnExecutedAsync(JobExecutedContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation("执行之后：{JobId} {TriggerId}", context.JobId, context.TriggerId);

        if (context.Exception != null)
        {
            _logger.LogError(context.Exception, "执行出错啦：{JobId} {TriggerId}", context.JobId, context.TriggerId);
        }

        return Task.CompletedTask;
    }
}
```

最后，在注册 `Schedule` 服务中注册 `YourJobMonitor`：

```cs showLineNumbers  {4}
services.AddSchedule(options =>
{
    // 添加作业执行监视器
    options.AddMonitor<YourJobMonitor>();
});
```

执行结果如下：

```bash showLineNumbers {2,6}
info: 2022-11-21 13:41:49.2144716 +08:00 星期一 L ConsoleApp32.YourJobMonitor[0] #9
      执行之前：job1 job1_trigger1
info: 2022-11-21 13:41:49.2216598 +08:00 星期一 L ConsoleApp32.MyJob[0] #9
      job1 job1_trigger1 2022/11/21 13:41:49  5000ms
info: 2022-11-21 13:41:49.2249096 +08:00 星期一 L ConsoleApp32.YourJobMonitor[0] #9
      执行之后：job1 job1_trigger1
```

### 26.1.8.1 关于参数 `JobExecutionContext`

`IJobMonitor` 提供的 `OnExecutingAsync` 和 `OnExecutedAsync` 接口方法都包含一个 `context` 参数，前者是 `JobExecutingContext`，后者是 `JobExecutedContext`，它们都有一个共同的基类 `JobExecutionContext`。

`JobExecutionContext` 提供了以下公共属性和公共方法:

- **`JobExecutionContext` 属性列表**
  - `JobId`：作业 `Id`
  - `TriggerId`：当前触发器 `Id`
  - `JobDetail`：作业信息
  - `Trigger`：作业触发器
  - `OccurrenceTime`：调度器检查时间，最准确的记录时间
- **`JobExecutionContext` 方法列表**
  - `.ConvertToJSON(naming)`：将作业计划转换成 `JSON` 字符串

<p></p>

- **`JobExecutingContext`** 在基类基础上拓展了 `ExecutingTime` 属性：
  - `ExecutingTime`：执行前时间
- **`JobExecutedContext`** 则在基类基础上拓展了 `ExecutedTime` 和 `Exception` 属性：
  - `ExecutedTime`：执行后时间
  - `Exception`：执行异常

## 26.1.9 作业执行器 `IJobExecutor`

调度作业服务提供了 `IJobExecutor` 执行器接口，可以让开发者自定义作业处理函数执行策略，如 `超时控制，失败重试、熔断等等`。

如添加 `YourJobExecutor`：

```cs showLineNumbers  {1,3,6-9}
public class YourJobExecutor : IJobExecutor
{
    public async Task ExecuteAsync(JobExecutingContext context, IJob jobHandler, CancellationToken stoppingToken)
    {
        // 实现失败重试策略，如失败重试 3 次
        await Retry.InvokeAsync(async () =>
        {
            await jobHandler.ExecuteAsync(context, stoppingToken);
        }, 3, 1000);
    }
}
```

接着模拟 `MyJob` 执行出错：

```cs showLineNumbers {1,14}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;

    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");

        throw new Exception("模拟出错");

        await Task.CompletedTask;
    }
}
```

最后，在注册 `Schedule` 服务中注册 `YourJobExecutor`：

```cs showLineNumbers  {5}
services.AddSchedule(options =>
{
      options.AddMonitor<YourJobMonitor>();
      // 添加作业执行器
      options.AddExecutor<YourJobExecutor>();
      options.AddJob<MyJob>(Triggers.PeriodSeconds(10));
});
```

执行结果如下：

```bash showLineNumbers {2,5-10,24,26}
info: 2022-11-21 14:10:33.3382344 +08:00 星期一 L ConsoleApp32.YourJobMonitor[0] #14
      执行之前：job1 job1_trigger1
info: 2022-11-21 14:10:33.3447855 +08:00 星期一 L ConsoleApp32.MyJob[0] #14
      job1 job1_trigger1 2022/11/21 14:10:33  10000ms
info: 2022-11-21 14:10:34.4217342 +08:00 星期一 L ConsoleApp32.MyJob[0] #14
      job1 job1_trigger1 2022/11/21 14:10:33  10000ms
info: 2022-11-21 14:10:35.4952165 +08:00 星期一 L ConsoleApp32.MyJob[0] #14
      job1 job1_trigger1 2022/11/21 14:10:33  10000ms
info: 2022-11-21 14:10:36.5719440 +08:00 星期一 L ConsoleApp32.MyJob[0] #14
      job1 job1_trigger1 2022/11/21 14:10:33  10000ms
fail: 2022-11-21 14:10:36.7388113 +08:00 星期一 L System.Logging.ScheduleService[0] #14
      Error occurred executing job1 job1_trigger1< 10000ms>.
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      System.Exception: 模拟出错
         at ConsoleApp32.MyJob.ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken) in D:\Workplaces\Study\CSharp\ConsoleApp32\ConsoleApp32\MyJob.cs:line 19
         at ConsoleApp32.YourJobExecutor.<>c__DisplayClass0_0.<<ExecuteAsync>b__0>d.MoveNext() in D:\Workplaces\Study\CSharp\ConsoleApp32\ConsoleApp32\YourJobExecutor.cs:line 18
      --- End of stack trace from previous location ---
         at Furion.FriendlyException.Retry.InvokeAsync(Func`1 action, Int32 numRetries, Int32 retryTimeout, Boolean finalThrow, Type[] exceptionTypes, Func`2 fallbackPolicy) in D:\Workplaces\OpenSources\Furion\framework\Furion\FriendlyException\Retry.cs:line 84
         at Furion.FriendlyException.Retry.InvokeAsync(Func`1 action, Int32 numRetries, Int32 retryTimeout, Boolean finalThrow, Type[] exceptionTypes, Func`2 fallbackPolicy) in D:\Workplaces\OpenSources\Furion\framework\Furion\FriendlyException\Retry.cs:line 95
         at ConsoleApp32.YourJobExecutor.ExecuteAsync(JobExecutingContext context, IJob jobHandler, CancellationToken stoppingToken) in D:\Workplaces\Study\CSharp\ConsoleApp32\ConsoleApp32\YourJobExecutor.cs:line 16
         at Furion.Schedule.ScheduleHostedService.<>c__DisplayClass16_2.<<BackgroundProcessing>b__1>d.MoveNext() in D:\Workplaces\OpenSources\Furion\framework\Furion\Schedule\HostedServices\ScheduleHostedService.cs:line 188
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
info: 2022-11-21 14:10:36.7413303 +08:00 星期一 L ConsoleApp32.YourJobMonitor[0] #14
      执行之后：job1 job1_trigger1
fail: 2022-11-21 14:10:36.7446968 +08:00 星期一 L ConsoleApp32.YourJobMonitor[0] #14
      执行出错啦：job1 job1_trigger1
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      System.InvalidOperationException: Error occurred executing job1 job1_trigger1< 10000ms>.
       ---> System.Exception: 模拟出错
         at ConsoleApp32.MyJob.ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken) in D:\Workplaces\Study\CSharp\ConsoleApp32\ConsoleApp32\MyJob.cs:line 19
         at ConsoleApp32.YourJobExecutor.<>c__DisplayClass0_0.<<ExecuteAsync>b__0>d.MoveNext() in D:\Workplaces\Study\CSharp\ConsoleApp32\ConsoleApp32\YourJobExecutor.cs:line 18
      --- End of stack trace from previous location ---
         at Furion.FriendlyException.Retry.InvokeAsync(Func`1 action, Int32 numRetries, Int32 retryTimeout, Boolean finalThrow, Type[] exceptionTypes, Func`2 fallbackPolicy) in D:\Workplaces\OpenSources\Furion\framework\Furion\FriendlyException\Retry.cs:line 84
         at Furion.FriendlyException.Retry.InvokeAsync(Func`1 action, Int32 numRetries, Int32 retryTimeout, Boolean finalThrow, Type[] exceptionTypes, Func`2 fallbackPolicy) in D:\Workplaces\OpenSources\Furion\framework\Furion\FriendlyException\Retry.cs:line 95
         at ConsoleApp32.YourJobExecutor.ExecuteAsync(JobExecutingContext context, IJob jobHandler, CancellationToken stoppingToken) in D:\Workplaces\Study\CSharp\ConsoleApp32\ConsoleApp32\YourJobExecutor.cs:line 16
         at Furion.Schedule.ScheduleHostedService.<>c__DisplayClass16_2.<<BackgroundProcessing>b__1>d.MoveNext() in D:\Workplaces\OpenSources\Furion\framework\Furion\Schedule\HostedServices\ScheduleHostedService.cs:line 188
         --- End of inner exception stack trace ---
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
```

## 26.1.10 作业计划工厂 `ISchedulerFactory`

作业计划工厂提供了程序运行时操作作业调度器，作业计划等诸多方法。

`ISchedulerFactory` 被注册为单例服务，允许在任何可依赖注入的服务获取，如：

```cs showLineNumbers {4,9}
public class YourService: IYourService
{
    private readonly ISchedulerFactory _schedulerFactory;
    public YourService(ISchedulerFactory schedulerFactory)
    {
        _schedulerFactory = schedulerFactory;
    }

    public void SomeMethod([FromServices]ISchedulerFactory schedulerFactory)
    {
    }
}
```

### 26.1.10.1 查找所有作业

```cs showLineNumbers {2,5,8-9}
// 返回的是 IScheduler 集合，不能访问 JobDetail 和 Triggers 属性
var jobs = _schedulerFactory.GetJobs();

// 返回的是 SchedulerModel 集合，可以访问 JobDetail 和 Triggers 属性
var jobsOfModels = _schedulerFactory.GetJobsOfModels();

// 还可以通过 group 查找
var jobs = _schedulerFactory.GetJobs("group1");
var jobsOfModels = _schedulerFactory.GetJobsOfModels("group1");
```

### 26.1.10.2 查找下一个触发的作业

```cs showLineNumbers {2,5,8,9}
// 返回的是 IScheduler 集合，不能访问 JobDetail 和 Triggers 属性
var nextRunJobs = _schedulerFactory.GetNextRunJobs(DateTime.Now);

// 返回的是 SchedulerModel 集合，可以访问 JobDetail 和 Triggers 属性
var nextRunJobsOfModels = _schedulerFactory.GetNextRunJobsOfModels(DateTime.Now);

// 还可以通过 group 查找
var nextRunJobs = _schedulerFactory.GetNextRunJobs("group1");
var nextRunJobsOfModels = _schedulerFactory.GetNextRunJobsOfModels("group1");
```

### 26.1.10.3 获取单个作业

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果存在返回 ScheduleResult.Succeed，否则返回 ScheduleResult.NotFound
var scheduleResult = _schedulerFactory.TryGetJob("job1", out var scheduler);

// 返回 IScheduler 类型
var scheduler = _schedulerFactory.GetJob("job1");
```

### 26.1.10.4 添加作业

- **通过 `SchedulerBuilder` 方式**

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var scheduleResult = _schedulerFactory.TryAddJob(schedulerBuilder, out var scheduler);

// 无返回值，无错误
_schedulerFactory.AddJob(schedulerBuilder);
```

作业添加成功或失败分别输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-21 16:24:03.5834532 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The Scheduler of <job1> successfully added to the schedule.
warn: 2022-11-21 16:24:03.5876747 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The JobId of <job1> already exists.
```

- **通过 `JobBuilder` + `TriggerBuilder` 方式**

```cs showLineNumbers {2,7}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = _schedulerFactory.TryAddJob(JobBuilder.Create<MyJob>()
            , new[] { Triggers.PeriodSeconds(10) }
            , out var scheduler);

// 无返回值，无错误
_schedulerFactory.AddJob(JobBuilder.Create<MyJob>()
            , Triggers.PeriodSeconds(10));
```

作业添加成功或失败分别输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-21 16:24:03.5834532 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The Scheduler of <job1> successfully added to the schedule.
warn: 2022-11-21 16:24:03.5876747 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The JobId of <job1> already exists.
```

- **通过 `IJob` 泛型方式**

```cs showLineNumbers {2,6}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = _schedulerFactory.TryAddJob<MyJob>(new[] { Triggers.PeriodSeconds(10) }
        , out var scheduler);

// 无返回值，无错误
_schedulerFactory.AddJob<MyJob>(Triggers.PeriodSeconds(10));
```

作业添加成功或失败分别输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-21 16:24:03.5834532 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The Scheduler of <job1> successfully added to the schedule.
warn: 2022-11-21 16:24:03.5876747 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The JobId of <job1> already exists.
```

- **通过 `IJob` 泛型 + `JobId` 方式**

```cs showLineNumbers {2,6}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = _schedulerFactory.TryAddJob<MyJob>("job1", new[] { Triggers.PeriodSeconds(10) }
        , out var scheduler);

// 无返回值，无错误
_schedulerFactory.AddJob<MyJob>("job1", Triggers.PeriodSeconds(10));
```

作业添加成功或失败分别输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-21 16:24:03.5834532 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The Scheduler of <job1> successfully added to the schedule.
warn: 2022-11-21 16:24:03.5876747 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The JobId of <job1> already exists.
```

- **通过 `IJob` 泛型 + `JobId` + `Concurrent` 方式**

```cs showLineNumbers {2,7}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = _schedulerFactory.TryAddJob<MyJob>("job1", concurrent: true
        , new[] { Triggers.PeriodSeconds(10) }
        , out var scheduler);

// 无返回值，无错误
_schedulerFactory.AddJob<MyJob>("job1", concurrent: true
        , Triggers.PeriodSeconds(10));
```

作业添加成功或失败分别输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-21 16:24:03.5834532 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The Scheduler of <job1> successfully added to the schedule.
warn: 2022-11-21 16:24:03.5876747 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The JobId of <job1> already exists.
```

- **通过 `IJob` 泛型 + `Concurrent` 方式**

```cs showLineNumbers {2,7}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = _schedulerFactory.TryAddJob<MyJob>(concurrent: true
        , new[] { Triggers.PeriodSeconds(10) }
        , out var scheduler);

// 无返回值，无错误
_schedulerFactory.AddJob<MyJob>(concurrent: true
        , Triggers.PeriodSeconds(10));
```

作业添加成功或失败分别输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-21 16:24:03.5834532 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The Scheduler of <job1> successfully added to the schedule.
warn: 2022-11-21 16:24:03.5876747 +08:00 星期一 L System.Logging.ScheduleService[0] #8
      The JobId of <job1> already exists.
```

- **还有其他更多重载方式**

```cs showLineNumbers {1,10}
// Type 类型方式
_schedulerFactory.TryAddJob(typeof(MyJob), new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob(typeof(MyJob), Triggers.PeriodSeconds(10));
_schedulerFactory.TryAddJob(typeof(MyJob), "作业 Id", new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob(typeof(MyJob), "作业 Id", Triggers.PeriodSeconds(10));
_schedulerFactory.TryAddJob(typeof(MyJob), "作业 Id", true, new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob(typeof(MyJob), "作业 Id", true, Triggers.PeriodSeconds(10));
_schedulerFactory.TryAddJob(typeof(MyJob), true, new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob(typeof(MyJob), true, Triggers.PeriodSeconds(10));
// 委托方式
_schedulerFactory.TryAddJob((s, c, t) => {}, new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob((s, c, t) => {}, Triggers.PeriodSeconds(10));
_schedulerFactory.TryAddJob((s, c, t) => {}, "作业 Id", new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob((s, c, t) => {}, "作业 Id", Triggers.PeriodSeconds(10));
_schedulerFactory.TryAddJob((s, c, t) => {}, "作业 Id", true, new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob((s, c, t) => {}, "作业 Id", true, Triggers.PeriodSeconds(10));
_schedulerFactory.TryAddJob((s, c, t) => {}, true, new[] { Triggers.PeriodSeconds(10) }, out var scheduler);
_schedulerFactory.AddJob((s, c, t) => {}, true, Triggers.PeriodSeconds(10));
```

### 26.1.10.5 更新作业

- **通过 `SchedulerBuilder` 方式**

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var scheduleResult = _schedulerFactory.TryUpdateJob(schedulerBuilder, out var scheduler);

// 无返回值，无错误
_schedulerFactory.UpdateJob(schedulerBuilder);
```

作业更新成功或失败分别输出日志：

```bash showLineNumbers {2,4,6}
info: 2022-11-21 18:13:13.0098096 +08:00 星期一 L System.Logging.ScheduleService[0] #14
      The Scheduler of <job1> successfully updated to the schedule.
warn: 2022-11-21 18:13:18.0098096 +08:00 星期一 L System.Logging.ScheduleService[0] #14
      The Scheduler of <job1> is not found.
warn: 2022-11-21 18:13:23.0098096 +08:00 星期一 L System.Logging.ScheduleService[0] #14
      The Scheduler of <job1> update failed.
```

:::tip 关于更新作业的背后行为

默认情况下，更新作业需要传递 `SchedulerBuilder` 对象，这个对象可通过 `GetJob(jobId)` 获取，如：

```cs showLineNumbers
var schedulerBuilder = _schedulerFactory.GetJob("jobId")?.GetBuilder();
```

此时它的内部 `Behavior` 属性被标记为 `PersistenceBehavior.Updated`，也就是更新状态，那么对于这个构建器的任何操作都会标记为 `更新` 操作。

如果通过 `.Appended()` 或 `.Removed()` 方法标记之后，那么它的操作行为就发生变化了。

- **如果被标记为 `.Appended()`**，如：

```cs showLineNumbers
schedulerBuilder.Appended();
```

那么它将进行 `新增` 操作，也就是内部会调用 `TryAddJob(schedulerBuilder)` 操作。

- **如果被标记为 `.Removed()`**，如：

```cs showLineNumbers
schedulerBuilder.Removed();
```

那么它将进行 `删除` 操作，也就是内部会调用 `TryRemoveJob(schedulerBuilder)` 操作。

比如以下的代码实则是 `新增` 或 `删除` 操作：

```cs showLineNumbers {3,7}
// 实际做新增操作
var scheduleResult = _schedulerFactory.TryUpdateJob(
      SchedulerBuilder.Create(JobBuilder.Create<MyJob>())); // Create 方法默认标记为 Appended

// 实际做删除操作
var schedulerBuilder = _schedulerFactory.GetJob("jobId")?.GetBuilder();
var scheduleResult = _schedulerFactory.TryUpdateJob(schedulerBuilder.Removed()); // 标记为 Removed
```

:::

### 26.1.10.6 删除作业

- **通过 `JobId` 方式**

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild 或者 ScheduleResult.NotFound
var schedulerResult = _schedulerFactory.TryRemoveJob("job1", out var scheduler);

// 无返回值，无错误
_schedulerFactory.RemoveJob("job1");
```

- **通过 `IScheduler` 方式**

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild 或者 ScheduleResult.NotFound
var schedulerResult = _schedulerFactory.TryRemoveJob(scheduler);

// 无返回值，无错误
_schedulerFactory.RemoveJob(scheduler);
```

作业删除成功或失败分别输出日志：

```bash showLineNumbers {2,4,6}
info: 2022-11-22 09:25:17.4763941 +08:00 星期二 L System.Logging.ScheduleService[0] #4
      The Scheduler of <job1> successfully removed to the schedule.
warn: 2022-11-22 09:28:56.2241923 +08:00 星期二 L System.Logging.ScheduleService[0] #9
      The Scheduler of <job12> is not found.
warn: 2022-11-22 09:29:01.2241923 +08:00 星期二 L System.Logging.ScheduleService[0] #9
      The Scheduler of <job1> remove failed.
```

### 26.1.10.7 检查作业是否存在

```cs showLineNumbers {1,4}
var isExist = _schedulerFactory.ContainsJob("job1");

// 还可以通过 group 查找
var isExist = _schedulerFactory.ContainsJob("job1", "group1");
```

### 26.1.10.8 启动所有作业

```cs showLineNumbers {1,4}
_schedulerFactory.StartAll();

// 还可以通过 group 启动
_schedulerFactory.StartAll("group1");
```

作业调度器输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-22 10:48:55.9619596 +08:00 星期二 L System.Logging.ScheduleService[0] #16
      The <job1_trigger1> trigger for scheduler of <job1> successfully started to the schedule.
warn: 2022-11-22 10:48:56.0131304 +08:00 星期二 L System.Logging.ScheduleService[0] #16
      Schedule Hosted Service cancels hibernation and GC.Collect().
```

### 26.1.10.9 暂停所有作业

```cs showLineNumbers {1,4}
 _schedulerFactory.PauseAll();

// 还可以通过 group 暂停
 _schedulerFactory.PauseAll("group1");
```

作业调度器输出日志：

```bash showLineNumbers {4,6}
info: 2022-11-22 11:01:52.0008851 +08:00 星期二 L ConsoleApp32.MyJob[0] #10
      job1 job1_trigger1 2022/11/22 11:01:51  5000ms
info: 2022-11-22 11:01:54.5265246 +08:00 星期二 L System.Logging.ScheduleService[0] #15
      The <job1_trigger1> trigger for scheduler of <job1> successfully paused to the schedule.
warn: 2022-11-22 11:01:54.5535267 +08:00 星期二 L System.Logging.ScheduleService[0] #15
      Schedule Hosted Service cancels hibernation and GC.Collect().
```

### 26.1.10.10 删除所有作业

```cs showLineNumbers {1,4}
 _schedulerFactory.RemoveAll();

// 还可以通过 group 删除
 _schedulerFactory.RemoveAll("group1");
```

作业调度器输出日志：

```bash showLineNumbers {4,6}
info: 2022-11-22 11:04:19.4838792 +08:00 星期二 L ConsoleApp32.MyJob[0] #14
      job1 job1_trigger1 2022/11/22 11:04:19  5000ms
warn: 2022-11-22 11:04:23.0726721 +08:00 星期二 L System.Logging.ScheduleService[0] #9
      Schedule Hosted Service cancels hibernation and GC.Collect().
info: 2022-11-22 11:04:23.0797010 +08:00 星期二 L System.Logging.ScheduleService[0] #9
      The Scheduler of <job1> successfully removed to the schedule.
```

### 26.1.10.11 强制唤醒作业调度器

正常情况下，作业调度器会自动管理休眠和唤醒，但一些特殊情况下需要强制唤醒作业调度器（比如调度器假死了，被回收了。。。），可通过以下方式：

```cs showLineNumbers
_schedulerFactory.CancelSleep();
```

作业调度器输出日志：

```bash showLineNumbers {2}
warn: 2022-11-22 11:04:23.0726721 +08:00 星期二 L System.Logging.ScheduleService[0] #9
      Schedule Hosted Service cancels hibernation and GC.Collect().
```

### 26.1.10.12 强制触发所有作业持久化

此操作会强制触发作业持久化器 `IJobPersistence` 的 `OnChanged` 和 `OnTriggerChanged` 方法，并标记作业持久化行为为 `PersistenceBehavior.Updated`。

```cs showLineNumbers {1,4}
_schedulerFactory.PersistAll();

// 还可以通过 group 控制
 _schedulerFactory.PersistAll("group1");
```

### 26.1.10.13 校对所有作业

有时候因为一些不确定的因素导致作业出现了极小的误差甚至停止执行，这时候可以通过校对作业进行修正。

```cs showLineNumbers {1,4}
_schedulerFactory.CollateAll();

// 还可以通过 group 控制
 _schedulerFactory.CollateAll("group1");
```

## 26.1.11 作业计划 `IScheduler`

作业计划 `Scheduler` 的默认实现接口是 `IScheduler`，该接口主要用来操作当前（单个）作业。

### 26.1.11.1 获取 `IScheduler` 实例

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果存在返回 ScheduleResult.Succeed，否则返回 ScheduleResult.NotFound
var scheduleResult = _schedulerFactory.TryGetJob("job1", out var scheduler);

// 返回 IScheduler 类型
var scheduler = _schedulerFactory.GetJob("job1");
```

### 26.1.11.2 获取 `SchedulerModel` 实例

获取 `SchedulerModel` 之后可直接访问 `JobDetail` 和 `Trigger` 对象。

```cs showLineNumbers
var schedulerModel = scheduler.GetModel();
```

### 26.1.11.3 获取 `SchedulerBuilder`

```cs showLineNumbers
var schedulerBuilder = scheduler.GetBuilder();
```

### 26.1.11.4 获取 `JobBuilder`

```cs showLineNumbers
var jobBuilder = scheduler.GetJobBuilder();
```

### 26.1.11.5 获取 `TriggerBuilders`

```cs showLineNumbers
var triggerBuilders = scheduler.GetTriggerBuilders();
```

### 26.1.11.6 获取单个 `TriggerBuilder`

```cs showLineNumbers
var triggerBuilder = scheduler.GetTriggerBuilder("trigger1");
```

### 26.1.11.7 启动当前作业

```cs showLineNumbers
scheduler.Start();
```

作业调度器输出日志：

```bash showLineNumbers {2,4}
info: 2022-11-22 17:38:16.2612604 +08:00 星期二 L System.Logging.ScheduleService[0] #15
      The <job1_trigger1> trigger for scheduler of <job1> successfully started to the schedule.
warn: 2022-11-22 17:38:16.2636849 +08:00 星期二 L System.Logging.ScheduleService[0] #15
      Schedule Hosted Service cancels hibernation and GC.Collect().
```

### 26.1.11.8 暂停当前作业

```cs showLineNumbers
schedular.Pause();
```

作业调度器输出日志：

```bash {4,6}
info: 2022-11-22 15:34:39.5609135 +08:00 星期二 L ConsoleApp32.MyJob[0] #8
      job1 job1_trigger1 2022/11/22 15:34:39  5000ms
info: 2022-11-22 15:34:39.5647151 +08:00 星期二 L System.Logging.ScheduleService[0] #14
      The <job1_trigger1> trigger for scheduler of <job1> successfully paused to the schedule.
warn: 2022-11-22 15:34:39.5682460 +08:00 星期二 L System.Logging.ScheduleService[0] #14
      Schedule Hosted Service cancels hibernation and GC.Collect().
```

### 26.1.11.9 启动作业特定触发器

```cs showLineNumbers
scheduler.StartTrigger("triggerId");
```

### 26.1.11.10 暂停作业特定触发器

```cs showLineNumbers
scheduler.PauseTrigger("triggerId");
```

### 26.1.11.11 更新作业信息

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = scheduler.TryUpdateDetail(jobBuilder, out var jobDetail);

// 无返回值，无错误
scheduler.UpdateDetail(jobBuilder);
```

### 26.1.11.12 获取作业单个触发器

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果存在返回 ScheduleResult.Succeed，否则返回 ScheduleResult.NotFound
var scheduleResult = scheduler.TryGetTrigger("trigger1", out var trigger);

// 返回 Trigger 类型
var trigger = scheduler.GetTrigger("trigger1");
```

### 26.1.11.13 添加作业单个触发器

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = scheduler.TryAddTrigger(triggerBuilder, out var trigger);

// 无返回值，无错误
scheduler.AddTrigger(triggerBuilder);
```

### 26.1.11.14 删除作业单个触发器

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild 或 ScheduleResult.NotFound
var schedulerResult = scheduler.TryRemoveTrigger("trigger1", out var trigger);

// 无返回值，无错误
scheduler.RemoveTrigger(triggerBuilder);
```

### 26.1.11.15 判断作业是否包含特定触发器

```cs showLineNumbers
var isExist = scheduler.ContainsTrigger("trigger1");
```

### 26.1.11.16 删除当前作业

```cs showLineNumbers {2,5}
// 返回 ScheduleResult 类型，如果添加成功返回 ScheduleResult.Succeed，否则返回 ScheduleResult.Faild
var schedulerResult = scheduler.TryRemove();

// 无返回值，无错误
scheduler.Remove();
```

### 26.1.11.17 强制触发所有作业持久化

此操作会强制触发作业持久化器 `IJobPersistence` 的 `OnChanged` 和 `OnTriggerChanged` 方法，并标记作业持久化行为为 `PersistenceBehavior.Updated`。

```cs showLineNumbers {1}
scheduler.Persist();
```

### 26.1.11.18 输出 `JSON` 字符串

```cs showLineNumbers
var json scheduler.ConvertToJSON();
```

输出结果为：

```json showLineNumbers {2,13}
{
  "jobDetail": {
    "jobId": "job1",
    "groupName": null,
    "jobType": "Furion.Application.MyJob",
    "assemblyName": "Furion.Application",
    "description": null,
    "concurrent": true,
    "includeAnnotations": false,
    "properties": "{}",
    "updatedTime": "2022-11-17T09:25:47.0471107+08:00"
  },
  "triggers": [
    {
      "triggerId": "job1_trigger1",
      "jobId": null,
      "triggerType": "Furion.Schedule.PeriodSecondsTrigger",
      "assemblyName": "Furion",
      "args": "[5]",
      "description": null,
      "status": 2,
      "startTime": null,
      "endTime": null,
      "lastRunTime": "2022-11-20T18:31:56.6859410+08:00",
      "nextRunTime": "2022-11-20T18:32:01.7233546+08:00",
      "numberOfRuns": 1,
      "maxNumberOfRuns": 0,
      "numberOfErrors": 0,
      "maxNumberOfErrors": 0,
      "numRetries": 0,
      "retryTimeout": 1000,
      "startNow": true,
      "runOnStart": false,
      "resetOnlyOnce": true,
      "updatedTime": "2022-11-20T18:31:56.7233630+08:00"
    }
  ]
}
```

### 26.1.11.19 校对作业

有时候因为一些不确定的因素导致作业出现了极小的误差甚至停止执行，这时候可以通过校对作业进行修正。

```cs showLineNumbers
scheduler.Collate();
```

## 26.1.12 作业持久化器 `IJobPersistence`

### 26.1.12.1 关于作业持久化器

作业持久化器指的是可以通过存储介质如数据库中加载作业信息到内存中，又可以将内存中作业调度器的作业信息实时同步回存储介质中。

### 26.1.12.2 实现作业持久化器

调度作业服务提供了非常简单的 `IJobPersistence` 接口，只需实现该接口即可实现持久化，如实现数据库持久化：

```cs showLineNumbers {1,3,9,17,23}
public class DbJobPersistence : IJobPersistence
{
    public IEnumerable<SchedulerBuilder> Preload()
    {
        // 作业调度服务启动时运行时初始化
        return Array.Empty<SchedulerBuilder>();
    }

    public SchedulerBuilder OnLoading(SchedulerBuilder builder)
    {
        // 如果是更新操作，则 return builder.Updated();
        // 如果是新增操作，则 return builder.Appended();
        // 如果是删除操作，则 return builder.Removed();
        return builder;
    }

    public void OnChanged(PersistenceContext context)
    {
        var sql = context.ConvertToSQL("job_detail");
        // 这里执行 sql 即可
    }

    public void OnTriggerChanged(PersistenceTriggerContext context)
    {
        var sql = context.ConvertToSQL("job_trigger");
        // 这里执行 sql 即可
    }
}
```

之后在 `Startup.cs` 中注册即可：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
      options.AddPersistence<DbJobPersistence>();
});
```

可能有些开发者看到这里一脸不解，持久化不应该这么简单啊！其实就是这么简单....

### 26.1.12.3 `IJobPersistence` 详细说明

`IJobPersistence` 接口提供了以下四个方法：

- **`Preload`：作业调度服务启动时调用，可在这里动态创建作业计划构建器并返回。**

```cs showLineNumbers {1,4,8,12,17}
public IEnumerable<SchedulerBuilder> Preload()
{
      // 这里可以扫描程序集动态创建返回
      return App.EffectiveTypes.Where(t => t.IsJobType())
                               .Select(t => SchedulerBuilder.Create(JobBuilder.Create(t), t.ScanTriggers()));

      // 如果类型贴有 [JobDetail] 特性，还可以一键扫描返回
      return App.EffectiveTypes.Where(t => t.IsJobType())
                               .Select(t => t.ScanToBuilder());

      // 还可以更简单~~
      return App.EffectiveTypes.ScanToBuilders();

      // 也可以手动返回
      return new[]
      {
            SchedulerBuilder.Create(JobBuilder.Create<MyJob>(), Triggers.Minutely())
      }
}
```

- **`OnLoading`：作业计划初始化通知，通常在这里进一步修改初始化作业计划构建器。**

在作业调度器服务启动时会遍历程序中所有作业计划构建器，然后逐条调用该方法，开发者可以在这里进一步修改作业计划构建器数据，之后**选择性返回 `SchedulerBuilder` 的持久化行为**。

`SchedulerBuilder` 提供 `Updated()`，`Appended()` 和 `Removed()` 来作为持久化行为标记，通常标记为 `Appended()`，也就是新增操作（默认值）。

```cs showLineNumbers {4,8,12-13,16}
public SchedulerBuilder OnLoading(SchedulerBuilder builder)
{
      // 比如这里修改作业信息描述
      builder.GetJobBuilder()
             .SetDescription("这是描述~~");

      // 还可以修改触发器
      builder.GetTriggerBuilder("trigger1")
             .SetDescription("这是触发器描述~~");

      // 还可以通过数据库查询返回填充 😎
      builder.GetJobBuilder()
             .LoadFrom(dbJobDetail); // dbJobDetail 表示根据 jobId 查询数据库返回的对象

      // 标记从其他地方更新，比如数据库
      return builder;
}
```

如果存储介质（如数据库）已经删除该作业，开发者可以标记为 `Removed()`，这样该作业会从内存中移除。

```cs showLineNumbers {3,6}
public SchedulerBuilder OnLoading(SchedulerBuilder builder)
{
      // 比如这里根据 jobId 查询数据库已经确认数据不存在了

      // 标记从其他地方移除
      return builder.Removed();
}
```

如果存储介质（如数据库）新增了新作业但内存中不存在，开发者可以标记为 `Append()`，这样该作业会添加到内存中，**但原有的 `builder` 就会被丢弃**。

```cs showLineNumbers {4,6,8,11}
public SchedulerBuilder OnLoading(SchedulerBuilder builder)
{
      // 比如在这里动态创建作业计划构建器
      var newBuilder = SchedulerBuilder.Create<MyJob>(Triggers.Minutely());
      // 还可以克隆一个
      var newBuilder = SchedulerBuilder.Clone(builder);
      // 还可以读取配置文件/JSON
      var newBuilder = SchedulerBuilder.From(json);

      // 返回新的作业计划构建器并标记为新增
      return newBuilder.Appended();
}
```

- **`OnChanged`：作业计划 `Scheduler` 的 `JobDetail` 变化时调用。**

只要作业计划有任何变化都将触发该方法，该方法有一个 `PersistenceContext` 类型的参数 `context`，`PersistenceContext` 包含以下成员：

- **`PersistenceContext` 属性列表**
  - `JobId`：作业 `Id`，`string` 类型
  - `JobDetail`：作业信息，`JobDetail` 类型
  - `Behavior`：持久化行为，`PersistenceBehavior` 枚举类型，包含 `Appended`，`Updated` 和 `Removed` 三个枚举成员
- **`PersistenceContext` 方法列表**
  - `ConvertToSQL`：将 `PersistenceContext` 转换成 `SQL` 字符串，`Behavior` 属性值不同，生成的 `SQL` 不同
  - `ConvertToJSON`：将 `PersistenceContext` 转换成 `JSON` 字符串
  - `ConvertToMonitor`：将 `PersistenceContext` 转换成 `Monitor` 字符串
  - `ToString`：将 `PersistenceContext` 转换成 `简要` 字符串
  - `GetNaming`：提供将特定字符串输出不同的命名规则字符串

```cs showLineNumbers {4,6,8,10}
public void OnChanged(PersistenceContext context)
{
      // 输出 CamelCase（驼峰命名法）SQL 语句，默认值
      var sql = context.ConvertToSQL("job_detail");
      // 输出 Pascal（帕斯卡命名法） SQL 语句
      var sql = context.ConvertToSQL("job_detail", NamingConventions.Pascal);
      // 输出 UnderScoreCase（下划线命名法） SQL 语句
      var sql = context.ConvertToSQL("job_detail", NamingConventions.UnderScoreCase);

      // 你要做的只是执行 SQL 了！！！ 😎
}
```

- **`OnTriggerChanged`：作业计划 `Scheduler` 的触发器 `Trigger` 变化时调用。**

只要作业计划**触发器**有任何变化都将触发该方法，该方法有一个 `PersistenceTriggerContext` 类型的参数 `context`，`PersistenceTriggerContext` 继承自 `PersistenceContext`：

- **`PersistenceTriggerContext` 属性列表**
  - `JobId`：作业 `Id`，`string` 类型
  - `JobDetail`：作业信息，`JobDetail` 类型
  - `TriggerId`：作业触发器 `Id`，`string` 类型
  - `Trigger`：作业触发器，`Trigger` 类型
  - `Behavior`：持久化行为，`PersistenceBehavior` 枚举类型，包含 `Appended`，`Updated` 和 `Removed` 三个枚举成员
- **`PersistenceTriggerContext` 方法列表**
  - `ConvertToSQL`：将 `PersistenceTriggerContext` 转换成 `SQL` 字符串，`Behavior` 属性值不同，生成的 `SQL` 不同
  - `ConvertToJSON`：将 `PersistenceTriggerContext` 转换成 `JSON` 字符串，只包含 `Trigger`
  - `ConvertAllToJSON`：将 `PersistenceTriggerContext` 转换成 `JSON` 字符串，包含 `JobDetail` 和 `Trigger`
  - `ConvertToMonitor`：将 `PersistenceTriggerContext` 转换成 `Monitor` 字符串
  - `ToString`：将 `PersistenceTriggerContext` 转换成 `简要` 字符串
  - `GetNaming`：提供将特定字符串输出不同的命名规则字符串

```cs showLineNumbers {4,6,8,10}
public void OnTriggerChanged(PersistenceTriggerContext context)
{
      // 输出 CamelCase（驼峰命名法）SQL 语句，默认值
      var sql = context.ConvertToSQL("job_trigger");
      // 输出 Pascal（帕斯卡命名法） SQL 语句
      var sql = context.ConvertToSQL("job_trigger", NamingConventions.Pascal);
      // 输出 UnderScoreCase（下划线命名法） SQL 语句
      var sql = context.ConvertToSQL("job_trigger", NamingConventions.UnderScoreCase);

      // 你要做的只是执行 SQL 了！！！ 😎
}
```

:::tip 小知识

默认情况下，生成的 `SQL` 属于标准 `SQL` 语句，但未必适合所有数据库类型，所以我们可以指定 `BuildSqlType` 来生成特定数据库的语句，如：

```cs showLineNumbers {4}
services.AddSchedule(options =>
{
      // 配置输出 SQL 的数据库类型，Furion 4.8.2.3+
      options.BuildSqlType = SqlTypes.SqlServer;
});
```

:::

### 26.1.12.4 各类数据库创建作业持久化表语句

<Tabs
  defaultValue="Sqlite"
  values={[
    {
      label: "Sqlite",
      value: "Sqlite",
    },
    {
      label: "SqlServer",
      value: "SqlServer",
    },
    {
      label: "MySQL",
      value: "MySQL",
    },
    {
      label: "PostgreSQL",
      value: "PostgreSQL",
    },
    {
      label: "Oracle",
      value: "Oracle",
    },
    {
      label: "Firebird",
      value: "Firebird",
    },
    {
      label: "EFCore",
      value: "EFCore",
    },
    {
      label: "SqlSugar",
      value: "SqlSugar",
    }
  ]}
>
  <TabItem value="Sqlite">

**可自行调整列命名规则。**

```sql showLineNumbers {1,14}
CREATE TABLE "JobDetails" (
    "Id" INTEGER NOT NULL CONSTRAINT "PK_JobDetails" PRIMARY KEY AUTOINCREMENT,
    "JobId" TEXT NOT NULL,
    "GroupName" TEXT NULL,
    "JobType" TEXT NULL,
    "AssemblyName" TEXT NULL,
    "Description" TEXT NULL,
    "Concurrent" INTEGER NOT NULL,
    "IncludeAnnotations" INTEGER NOT NULL,
    "Properties" TEXT NULL,
    "UpdatedTime" TEXT NULL
);

CREATE TABLE "JobTriggers" (
    "Id" INTEGER NOT NULL CONSTRAINT "PK_JobTriggers" PRIMARY KEY AUTOINCREMENT,
    "TriggerId" TEXT NOT NULL,
    "JobId" TEXT NOT NULL,
    "TriggerType" TEXT NULL,
    "AssemblyName" TEXT NULL,
    "Args" TEXT NULL,
    "Description" TEXT NULL,
    "Status" INTEGER NOT NULL,
    "StartTime" TEXT NULL,
    "EndTime" TEXT NULL,
    "LastRunTime" TEXT NULL,
    "NextRunTime" TEXT NULL,
    "NumberOfRuns" INTEGER NOT NULL,
    "MaxNumberOfRuns" INTEGER NOT NULL,
    "NumberOfErrors" INTEGER NOT NULL,
    "MaxNumberOfErrors" INTEGER NOT NULL,
    "NumRetries" INTEGER NOT NULL,
    "RetryTimeout" INTEGER NOT NULL,
    "StartNow" INTEGER NOT NULL,
    "RunOnStart" INTEGER NOT NULL,
    "ResetOnlyOnce" INTEGER NOT NULL,
    "UpdatedTime" TEXT NULL
);
```

  </TabItem>
  <TabItem value="SqlServer">

**可自行调整列命名规则。**

```sql showLineNumbers {1,16}
CREATE TABLE [JobDetails] (
    [Id] int NOT NULL IDENTITY,
    [JobId] nvarchar(max) NOT NULL,
    [GroupName] nvarchar(max) NULL,
    [JobType] nvarchar(max) NULL,
    [AssemblyName] nvarchar(max) NULL,
    [Description] nvarchar(max) NULL,
    [Concurrent] bit NOT NULL,
    [IncludeAnnotations] bit NOT NULL,
    [Properties] nvarchar(max) NULL,
    [UpdatedTime] datetime2 NULL,
    CONSTRAINT [PK_JobDetails] PRIMARY KEY ([Id])
);
GO

CREATE TABLE [JobTriggers] (
    [Id] int NOT NULL IDENTITY,
    [TriggerId] nvarchar(max) NOT NULL,
    [JobId] nvarchar(max) NOT NULL,
    [TriggerType] nvarchar(max) NULL,
    [AssemblyName] nvarchar(max) NULL,
    [Args] nvarchar(max) NULL,
    [Description] nvarchar(max) NULL,
    [Status] bigint NOT NULL,
    [StartTime] datetime2 NULL,
    [EndTime] datetime2 NULL,
    [LastRunTime] datetime2 NULL,
    [NextRunTime] datetime2 NULL,
    [NumberOfRuns] bigint NOT NULL,
    [MaxNumberOfRuns] bigint NOT NULL,
    [NumberOfErrors] bigint NOT NULL,
    [MaxNumberOfErrors] bigint NOT NULL,
    [NumRetries] int NOT NULL,
    [RetryTimeout] int NOT NULL,
    [StartNow] bit NOT NULL,
    [RunOnStart] bit NOT NULL,
    [ResetOnlyOnce] bit NOT NULL,
    [UpdatedTime] datetime2 NULL,
    CONSTRAINT [PK_JobTriggers] PRIMARY KEY ([Id])
);
```

  </TabItem>
  <TabItem value="MySQL">

**可自行调整列命名规则。**

```sql showLineNumbers {3,17}
ALTER DATABASE CHARACTER SET utf8mb4;

CREATE TABLE `JobDetails` (
    `Id` int NOT NULL AUTO_INCREMENT,
    `JobId` longtext CHARACTER SET utf8mb4 NOT NULL,
    `GroupName` longtext CHARACTER SET utf8mb4 NULL,
    `JobType` longtext CHARACTER SET utf8mb4 NULL,
    `AssemblyName` longtext CHARACTER SET utf8mb4 NULL,
    `Description` longtext CHARACTER SET utf8mb4 NULL,
    `Concurrent` tinyint(1) NOT NULL,
    `IncludeAnnotations` tinyint(1) NOT NULL,
    `Properties` longtext CHARACTER SET utf8mb4 NULL,
    `UpdatedTime` datetime(6) NULL,
    CONSTRAINT `PK_JobDetails` PRIMARY KEY (`Id`)
) CHARACTER SET=utf8mb4;

CREATE TABLE `JobTriggers` (
    `Id` int NOT NULL AUTO_INCREMENT,
    `TriggerId` longtext CHARACTER SET utf8mb4 NOT NULL,
    `JobId` longtext CHARACTER SET utf8mb4 NOT NULL,
    `TriggerType` longtext CHARACTER SET utf8mb4 NULL,
    `AssemblyName` longtext CHARACTER SET utf8mb4 NULL,
    `Args` longtext CHARACTER SET utf8mb4 NULL,
    `Description` longtext CHARACTER SET utf8mb4 NULL,
    `Status` int unsigned NOT NULL,
    `StartTime` datetime(6) NULL,
    `EndTime` datetime(6) NULL,
    `LastRunTime` datetime(6) NULL,
    `NextRunTime` datetime(6) NULL,
    `NumberOfRuns` bigint NOT NULL,
    `MaxNumberOfRuns` bigint NOT NULL,
    `NumberOfErrors` bigint NOT NULL,
    `MaxNumberOfErrors` bigint NOT NULL,
    `NumRetries` int NOT NULL,
    `RetryTimeout` int NOT NULL,
    `StartNow` tinyint(1) NOT NULL,
    `RunOnStart` tinyint(1) NOT NULL,
    `ResetOnlyOnce` tinyint(1) NOT NULL,
    `UpdatedTime` datetime(6) NULL,
    CONSTRAINT `PK_JobTriggers` PRIMARY KEY (`Id`)
) CHARACTER SET=utf8mb4;
```

  </TabItem>
  <TabItem value="PostgreSQL">

**可自行调整列命名规则。**

```sql showLineNumbers {1,15}
CREATE TABLE "JobDetails" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "JobId" text NOT NULL,
    "GroupName" text NULL,
    "JobType" text NULL,
    "AssemblyName" text NULL,
    "Description" text NULL,
    "Concurrent" boolean NOT NULL,
    "IncludeAnnotations" boolean NOT NULL,
    "Properties" text NULL,
    "UpdatedTime" timestamp with time zone NULL,
    CONSTRAINT "PK_JobDetails" PRIMARY KEY ("Id")
);

CREATE TABLE "JobTriggers" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "TriggerId" text NOT NULL,
    "JobId" text NOT NULL,
    "TriggerType" text NULL,
    "AssemblyName" text NULL,
    "Args" text NULL,
    "Description" text NULL,
    "Status" bigint NOT NULL,
    "StartTime" timestamp with time zone NULL,
    "EndTime" timestamp with time zone NULL,
    "LastRunTime" timestamp with time zone NULL,
    "NextRunTime" timestamp with time zone NULL,
    "NumberOfRuns" bigint NOT NULL,
    "MaxNumberOfRuns" bigint NOT NULL,
    "NumberOfErrors" bigint NOT NULL,
    "MaxNumberOfErrors" bigint NOT NULL,
    "NumRetries" integer NOT NULL,
    "RetryTimeout" integer NOT NULL,
    "StartNow" boolean NOT NULL,
    "RunOnStart" boolean NOT NULL,
    "ResetOnlyOnce" boolean NOT NULL,
    "UpdatedTime" timestamp with time zone NULL,
    CONSTRAINT "PK_JobTriggers" PRIMARY KEY ("Id")
);
```

  </TabItem>
  <TabItem value="Oracle">

**可自行调整列命名规则。**

```sql showLineNumbers {1,15}
CREATE TABLE "JobDetails" (
    "Id" NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    "JobId" NVARCHAR2(2000) NOT NULL,
    "GroupName" NVARCHAR2(2000),
    "JobType" NVARCHAR2(2000),
    "AssemblyName" NVARCHAR2(2000),
    "Description" NVARCHAR2(2000),
    "Concurrent" NUMBER(1) NOT NULL,
    "IncludeAnnotations" NUMBER(1) NOT NULL,
    "Properties" NVARCHAR2(2000),
    "UpdatedTime" TIMESTAMP(7),
    CONSTRAINT "PK_JobDetails" PRIMARY KEY ("Id")
);

CREATE TABLE "JobTriggers" (
    "Id" NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY NOT NULL,
    "TriggerId" NVARCHAR2(2000) NOT NULL,
    "JobId" NVARCHAR2(2000) NOT NULL,
    "TriggerType" NVARCHAR2(2000),
    "AssemblyName" NVARCHAR2(2000),
    "Args" NVARCHAR2(2000),
    "Description" NVARCHAR2(2000),
    "Status" NUMBER(10) NOT NULL,
    "StartTime" TIMESTAMP(7),
    "EndTime" TIMESTAMP(7),
    "LastRunTime" TIMESTAMP(7),
    "NextRunTime" TIMESTAMP(7),
    "NumberOfRuns" NUMBER(19) NOT NULL,
    "MaxNumberOfRuns" NUMBER(19) NOT NULL,
    "NumberOfErrors" NUMBER(19) NOT NULL,
    "MaxNumberOfErrors" NUMBER(19) NOT NULL,
    "NumRetries" NUMBER(10) NOT NULL,
    "RetryTimeout" NUMBER(10) NOT NULL,
    "StartNow" NUMBER(1) NOT NULL,
    "RunOnStart" NUMBER(1) NOT NULL,
    "ResetOnlyOnce" NUMBER(1) NOT NULL,
    "UpdatedTime" TIMESTAMP(7),
    CONSTRAINT "PK_JobTriggers" PRIMARY KEY ("Id")
);
```

  </TabItem>
  <TabItem value="Firebird">

**可自行调整列命名规则。**

```sql showLineNumbers {1,15}
CREATE TABLE "JobDetails" (
    "Id" INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "JobId" BLOB SUB_TYPE TEXT NOT NULL,
    "GroupName" BLOB SUB_TYPE TEXT,
    "JobType" BLOB SUB_TYPE TEXT,
    "AssemblyName" BLOB SUB_TYPE TEXT,
    "Description" BLOB SUB_TYPE TEXT,
    "Concurrent" BOOLEAN NOT NULL,
    "IncludeAnnotations" BOOLEAN NOT NULL,
    "Properties" BLOB SUB_TYPE TEXT,
    "UpdatedTime" TIMESTAMP,
    CONSTRAINT "PK_JobDetails" PRIMARY KEY ("Id")
);

CREATE TABLE "JobTriggers" (
    "Id" INTEGER GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    "TriggerId" BLOB SUB_TYPE TEXT NOT NULL,
    "JobId" BLOB SUB_TYPE TEXT NOT NULL,
    "TriggerType" BLOB SUB_TYPE TEXT,
    "AssemblyName" BLOB SUB_TYPE TEXT,
    "Args" BLOB SUB_TYPE TEXT,
    "Description" BLOB SUB_TYPE TEXT,
    "Status" BIGINT NOT NULL,
    "StartTime" TIMESTAMP,
    "EndTime" TIMESTAMP,
    "LastRunTime" TIMESTAMP,
    "NextRunTime" TIMESTAMP,
    "NumberOfRuns" BIGINT NOT NULL,
    "MaxNumberOfRuns" BIGINT NOT NULL,
    "NumberOfErrors" BIGINT NOT NULL,
    "MaxNumberOfErrors" BIGINT NOT NULL,
    "NumRetries" INTEGER NOT NULL,
    "RetryTimeout" INTEGER NOT NULL,
    "StartNow" BOOLEAN NOT NULL,
    "RunOnStart" BOOLEAN NOT NULL,
    "ResetOnlyOnce" BOOLEAN NOT NULL,
    "UpdatedTime" TIMESTAMP,
    CONSTRAINT "PK_JobTriggers" PRIMARY KEY ("Id")
);
```

  </TabItem>
  <TabItem value="EFCore">

**可自行调整列命名规则。**

```cs showLineNumbers {1,56}
public class JobDetail
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public int Id { get; set; }

    /// <summary>
    /// 作业 Id
    /// </summary>
    public string JobId { get; set; }

    /// <summary>
    /// 作业组名称
    /// </summary>
    public string? GroupName { get; set; }

    /// <summary>
    /// 作业处理程序类型
    /// </summary>
    /// <remarks>存储的是类型的 FullName</remarks>
    public string? JobType { get; set; }

    /// <summary>
    /// 作业处理程序类型所在程序集
    /// </summary>
    /// <remarks>存储的是程序集 Name</remarks>
    public string? AssemblyName { get; set; }

    /// <summary>
    /// 描述信息
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// 是否采用并行执行
    /// </summary>
    /// <remarks>如果设置为 false，那么使用串行执行</remarks>
    public bool Concurrent { get; set; } = true;

    /// <summary>
    /// 是否扫描 IJob 实现类 [Trigger] 特性触发器
    /// </summary>
    public bool IncludeAnnotations { get; set; } = false;

    /// <summary>
    /// 作业信息额外数据
    /// </summary>
    public string? Properties { get; set; } = "{}";

    /// <summary>
    /// 作业更新时间
    /// </summary>
    public DateTime? UpdatedTime { get; set; }
}

public class JobTrigger
{
    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
    public int Id { get; set; }

    /// <summary>
    /// 作业触发器 Id
    /// </summary>
    public string TriggerId { get; set; }

    /// <summary>
    /// 作业 Id
    /// </summary>
    public string JobId { get; set; }

    /// <summary>
    /// 作业触发器类型
    /// </summary>
    /// <remarks>存储的是类型的 FullName</remarks>
    public string? TriggerType { get; set; }

    /// <summary>
    /// 作业触发器类型所在程序集
    /// </summary>
    /// <remarks>存储的是程序集 Name</remarks>
    public string? AssemblyName { get; set; }

    /// <summary>
    /// 作业触发器参数
    /// </summary>
    /// <remarks>运行时将反序列化为 object[] 类型并作为构造函数参数</remarks>
    public string? Args { get; set; }

    /// <summary>
    /// 描述信息
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// 作业触发器状态
    /// </summary>
    public TriggerStatus Status { get; set; } = TriggerStatus.Ready;

    /// <summary>
    /// 起始时间
    /// </summary>
    public DateTime? StartTime { get; set; }

    /// <summary>
    /// 结束时间
    /// </summary>
    public DateTime? EndTime { get; set; }

    /// <summary>
    /// 最近运行时间
    /// </summary>
    public DateTime? LastRunTime { get; set; }

    /// <summary>
    /// 下一次运行时间
    /// </summary>
    public DateTime? NextRunTime { get; set; }

    /// <summary>
    /// 触发次数
    /// </summary>
    public long NumberOfRuns { get; set; }

    /// <summary>
    /// 最大触发次数
    /// </summary>
    /// <remarks>
    /// <para>0：不限制</para>
    /// <para>n：N 次</para>
    /// </remarks>
    public long MaxNumberOfRuns { get; set; }

    /// <summary>
    /// 出错次数
    /// </summary>
    public long NumberOfErrors { get; set; }

    /// <summary>
    /// 最大出错次数
    /// </summary>
    /// <remarks>
    /// <para>0：不限制</para>
    /// <para>n：N 次</para>
    /// </remarks>
    public long MaxNumberOfErrors { get; set; }

    /// <summary>
    /// 重试次数
    /// </summary>
    public int NumRetries { get; set; } = 0;

    /// <summary>
    /// 重试间隔时间
    /// </summary>
    /// <remarks>默认1000毫秒</remarks>
    public int RetryTimeout { get; set; } = 1000;

    /// <summary>
    /// 是否立即启动
    /// </summary>
    public bool StartNow { get; set; } = true;

    /// <summary>
    /// 是否启动时执行一次
    /// </summary>
    public bool RunOnStart { get; set; } = false;

    /// <summary>
    /// 是否在启动时重置最大触发次数等于一次的作业
    /// </summary>
    /// <remarks>解决因持久化数据已完成一次触发但启动时不再执行的问题</remarks>
    public bool ResetOnlyOnce { get; set; } = true;

    /// <summary>
    /// 作业触发器更新时间
    /// </summary>
    public DateTime? UpdatedTime { get; set; }
}
```

  </TabItem>
  <TabItem value="SqlSugar">

**可自行调整列命名规则。**

```cs showLineNumbers {2,66}
[SugarTable("JobDetail", "作业信息表")]
public class JobDetail
{
    /// <summary>
    /// Id
    /// </summary>
    [SugarColumn(ColumnDescription = "Id", IsPrimaryKey = true, IsIdentity = true)]
    public virtual long Id { get; set; }

    /// <summary>
    /// 作业 Id
    /// </summary>
    [SugarColumn(ColumnDescription = "作业Id")]
    public virtual string JobId { get; set; }

    /// <summary>
    /// 组名称
    /// </summary>
    [SugarColumn(ColumnDescription = "组名称")]
    public string? GroupName { get; set; }

    /// <summary>
    /// 作业类型 FullName
    /// </summary>
    [SugarColumn(ColumnDescription = "作业类型")]
    public string? JobType { get; set; }

    /// <summary>
    /// 程序集 Name
    /// </summary>
    [SugarColumn(ColumnDescription = "程序集")]
    public string? AssemblyName { get; set; }

    /// <summary>
    /// 描述信息
    /// </summary>
    [SugarColumn(ColumnDescription = "描述信息")]
    public string? Description { get; set; }

    /// <summary>
    /// 是否并行执行
    /// </summary>
    [SugarColumn(ColumnDescription = "是否并行执行")]
    public bool Concurrent { get; set; } = true;

    /// <summary>
    /// 是否扫描特性触发器
    /// </summary>
    [SugarColumn(ColumnDescription = "是否扫描特性触发器")]
    public bool IncludeAnnotations { get; set; } = false;

    /// <summary>
    /// 额外数据
    /// </summary>
    [SugarColumn(ColumnDescription = "额外数据", ColumnDataType = "longtext,text,clob")]
    public string? Properties { get; set; } = "{}";

    /// <summary>
    /// 更新时间
    /// </summary>
    [SugarColumn(ColumnDescription = "更新时间")]
    public DateTime? UpdatedTime { get; set; }
}

[SugarTable("JobTrigger", "作业触发器表")]
public class JobTrigger
{
    /// <summary>
    /// Id
    /// </summary>
    [SugarColumn(ColumnDescription = "Id", IsPrimaryKey = true, IsIdentity = true)]
    public virtual long Id { get; set; }

    /// <summary>
    /// 触发器 Id
    /// </summary>
    [SugarColumn(ColumnDescription = "触发器Id")]
    public virtual string TriggerId { get; set; }

    /// <summary>
    /// 作业 Id
    /// </summary>
    [SugarColumn(ColumnDescription = "作业Id")]
    public virtual string JobId { get; set; }

    /// <summary>
    /// 触发器类型 FullName
    /// </summary>
    [SugarColumn(ColumnDescription = "触发器类型")]
    public string? TriggerType { get; set; }

    /// <summary>
    /// 程序集 Name
    /// </summary>
    [SugarColumn(ColumnDescription = "程序集")]
    public string? AssemblyName { get; set; }

    /// <summary>
    /// 参数
    /// </summary>
    [SugarColumn(ColumnDescription = "参数")]
    public string? Args { get; set; }

    /// <summary>
    /// 描述信息
    /// </summary>
    [SugarColumn(ColumnDescription = "描述信息")]
    public string? Description { get; set; }

    /// <summary>
    /// 状态
    /// </summary>
    [SugarColumn(ColumnDescription = "状态")]
    public TriggerStatus Status { get; set; } = TriggerStatus.Ready;

    /// <summary>
    /// 起始时间
    /// </summary>
    [SugarColumn(ColumnDescription = "起始时间")]
    public DateTime? StartTime { get; set; }

    /// <summary>
    /// 结束时间
    /// </summary>
    [SugarColumn(ColumnDescription = "结束时间")]
    public DateTime? EndTime { get; set; }

    /// <summary>
    /// 最近运行时间
    /// </summary>
    [SugarColumn(ColumnDescription = "最近运行时间")]
    public DateTime? LastRunTime { get; set; }

    /// <summary>
    /// 下一次运行时间
    /// </summary>
    [SugarColumn(ColumnDescription = "下一次运行时间")]
    public DateTime? NextRunTime { get; set; }

    /// <summary>
    /// 触发次数
    /// </summary>
    [SugarColumn(ColumnDescription = "触发次数")]
    public long NumberOfRuns { get; set; }

    /// <summary>
    /// 最大触发次数（0:不限制，n:N次）
    /// </summary>
    [SugarColumn(ColumnDescription = "最大触发次数")]
    public long MaxNumberOfRuns { get; set; }

    /// <summary>
    /// 出错次数
    /// </summary>
    [SugarColumn(ColumnDescription = "出错次数")]
    public long NumberOfErrors { get; set; }

    /// <summary>
    /// 最大出错次数（0:不限制，n:N次）
    /// </summary>
    [SugarColumn(ColumnDescription = "最大出错次数")]
    public long MaxNumberOfErrors { get; set; }

    /// <summary>
    /// 重试次数
    /// </summary>
    [SugarColumn(ColumnDescription = "重试次数")]
    public int NumRetries { get; set; }

    /// <summary>
    /// 重试间隔时间（ms）
    /// </summary>
    [SugarColumn(ColumnDescription = "重试间隔时间(ms)")]
    public int RetryTimeout { get; set; } = 1000;

    /// <summary>
    /// 是否立即启动
    /// </summary>
    [SugarColumn(ColumnDescription = "是否立即启动")]
    public bool StartNow { get; set; } = true;

    /// <summary>
    /// 是否启动时执行一次
    /// </summary>
    [SugarColumn(ColumnDescription = "是否启动时执行一次")]
    public bool RunOnStart { get; set; } = false;

    /// <summary>
    /// 是否在启动时重置最大触发次数等于一次的作业
    /// </summary>
    /// <remarks>解决因持久化数据已完成一次触发但启动时不再执行的问题</remarks>
    [SugarColumn(ColumnDescription = "是否在启动时重置最大触发次数等于一次的作业")]
    public bool ResetOnlyOnce { get; set; } = true;

    /// <summary>
    /// 更新时间
    /// </summary>
    [SugarColumn(ColumnDescription = "更新时间")]
    public DateTime? UpdatedTime { get; set; }
}
```

  </TabItem>
</Tabs>

## 26.1.13 作业集群控制

框架提供简单的集群功能，但并不能达到负载均衡的效果，而仅仅提供了故障转移的功能，当一个服务的作业调度器宕机时，另一个服务的作业调度器会启动。

### 26.1.13.1 实现集群故障转移

1. **创建 `JobClusterServer` 类并实现 `IJobClusterServer`**

```cs showLineNumbers {1,9,21-37,46,55,65}
public class JobClusterServer : IJobClusterServer
{
    /// <summary>
    /// 当前作业调度器启动通知
    /// </summary>
    /// <param name="context">作业集群服务上下文</param>
    public void Start(JobClusterContext context)
    {
        // 在作业集群表中，如果 clusterId 不存在，则新增一条（否则更新一条），并设置 status 为 ClusterStatus.Waiting
    }

    /// <summary>
    /// 等待被唤醒
    /// </summary>
    /// <param name="context">作业集群服务上下文</param>
    /// <returns><see cref="Task"/></returns>
    public async Task WaitingForAsync(JobClusterContext context)
    {
        var clusterId = context.ClusterId;

        while (true)
        {
            try
            {
                // 在这里查询数据库，根据以下两种情况处理
                // 1) 如果作业集群表已有 status 为 ClusterStatus.Working 则继续循环
                // 2) 如果作业集群表中还没有其他服务或只有自己，则插入一条集群服务或调用 await WorkNowAsync(clusterId); 之后 return;
                // 3) 如果作业集群表中没有 status 为 ClusterStatus.Working 的，调用 await WorkNowAsync(clusterId); 之后 return;

                await WorkNowAsync(clusterId);
                return;
            }
            catch { }

            // 控制集群心跳频率
            await Task.Delay(3000);
        }
    }

    /// <summary>
    /// 当前作业调度器停止通知
    /// </summary>
    /// <param name="context">作业集群服务上下文</param>
    public void Stop(JobClusterContext context)
    {
        // 在作业集群表中，更新 clusterId 的 status 为 ClusterStatus.Crashed
    }

    /// <summary>
    /// 当前作业调度器宕机
    /// </summary>
    /// <param name="context">作业集群服务上下文</param>
    public void Crash(JobClusterContext context)
    {
        // 在作业集群表中，更新 clusterId 的 status 为 ClusterStatus.Crashed
    }

    /// <summary>
    /// 指示集群可以工作
    /// </summary>
    /// <param name="clusterId">集群 Id</param>
    /// <returns></returns>
    private Task WorkNowAsync(string clusterId)
    {
        // 在作业集群表中，更新 clusterId 的 status 为 ClusterStatus.Working

        return Task.CompletedTask;
    }
}
```

2. **注册集群服务**

```cs showLineNumbers {3-4}
services.AddSchedule(options =>
{
      options.ClusterId = "cluster1";
      options.AddClusterServer<JobClusterServer>();
});
```

3. **作业集群输出日志**

```bash showLineNumbers {4,6,8,12}
info: 2022-11-23 14:08:35.4253321 +08:00 星期三 L System.Logging.ScheduleService[0] #1
      Schedule Hosted Service is running.
info: 2022-11-23 14:08:35.4391070 +08:00 星期三 L System.Logging.ScheduleService[0] #1
      The job cluster of <cluster1> service has been enabled, waiting for instructions.
warn: 2022-11-23 14:08:38.4590092 +08:00 星期三 L System.Logging.ScheduleService[0] #8
      The job cluster of <cluster1> service has been enabled, and the current job scheduler can work normally.
warn: 2022-11-23 14:08:38.4823786 +08:00 星期三 L System.Logging.ScheduleService[0] #8
      Schedule Hosted Service cancels hibernation and GC.Collect().
info: 2022-11-23 14:08:38.4909379 +08:00 星期三 L System.Logging.ScheduleService[0] #8
      The Scheduler of <job1> successfully updated to the schedule.
info: 2022-11-23 14:08:43.5211812 +08:00 星期三 L ConsoleApp32.MyJob[0] #15
      <job1>   <job1 job1_trigger1>  5000ms 2022/11/23 14:08:43
```

### 26.1.13.2 作业集群数据库表设计

只需包含 `Id`，`ClusterId`，`Description`，`Status`，`UpdatedTime` 字段即可，其中 `Status` 是 `ClusterStatus` 枚举类型。

- **`ClusterStatus`** 包含以下枚举成员
  - `Crashed`：宕机
  - `Working`：正常工作
  - `Waiting`：等待被唤醒，默认值

### 26.1.13.3 如何实现负载均衡

框架只提供了简单的故障转移的集群功能，如需实现负载均衡，可通过 `TCP/IP` 套接字实现，这里看后续需求，如果需求大，就把完整的负载均衡例子补上。

## 26.1.14 `ScheduleServe` 静态类

该功能 **建议** 仅限不能通过 `services.AddXXX` 方式使用，比如控制台，`Winfrom/WPF` 等。

```cs showLineNumbers {1,3}
IDisposable dispose =  ScheduleServe.Run(options =>
{
    options.AddJob<MyJob>(Triggers.Secondly());
});
```

这种方式有一个隐藏的巨大隐藏 “骚操作”：**可以在任何地方创建作业调度服务，多次调用可以创建多个作业调度器。**

:::tip 推荐使用 `Serve.Run()` 或 `Serve.RunGeneric()` 方式替代

`Furion` 框架提供了 `Serve.Run()` 方式支持跨平台使用，还能支持注册更多服务，如：

```cs showLineNumbers {1,3,5}
Serve.Run(services =>
{
    services.AddSchedule(options =>
    {
        options.Add<MyJob>(Triggers.Secondly());
    });
})
```

如无需 `Web` 功能，可通过 `Serve.RunGeneric` 替代 `Serve.Run`。

:::

## 26.1.15 如何部署

如果在项目中使用了定时任务且部署到 `IIS` 中，那么需要设置 `IIS` 禁止回收，[点击查看 `IIS` 回收问题解决方案](/docs/deploy-iis#3415-iis-%E5%9B%9E%E6%94%B6%E9%97%AE%E9%A2%98%E5%92%8C%E9%85%8D%E7%BD%AE)

:::warning 部署建议

建议定时任务采用 `Worker Service` 独立部署方式，不应依托 `Web` 项目进程中。[查看【 Worker Service】章节](/docs/process-service.mdx)

:::

## 26.1.16 常见问题

### 26.1.16.1 作业触发时间存在偏差

通常我们会在 `IJob` 实现类型中获取当前时间，但是这个时间可能存在着极小的误差，如：

```cs showLineNumbers {5,8}
public class MyJob : IJob
{
    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var nowTime = DateTime.Now; // 此时的时间未必是真实触发时间，因为还包含创建线程，初始化等等时间

        // 正确的做法是
        var nowTime = context.OccurrenceTime;
    }
}
```

## 26.1.17 反馈与建议

:::note 与我们交流

给 Furion 提 [Issue](https://gitee.com/dotnetchina/Furion/issues/new?issue)。

:::
