---
id: job
title: 26.1 调度作业
sidebar_label: 26.1 调度作业
---

:::caution 当前文档还未发布

**当前文档还在编写中，只完成了 55%，将在 2022 年 11 月 21 日前完成。**

:::

---

:::warning 4.8.0 以下版本说明

**在 `Furion 4.8.0+` 版本采用 [Sundial](https://gitee.com/dotnetchina/Sundial) 定时任务替换原有的 `TaskScheduler`**，[查看旧文档](/docs/job-old)

:::

:::important 版本说明

以下内容仅限 `Furion 4.8.0 +` 版本使用。

:::

import useBaseUrl from "@docusaurus/useBaseUrl";

## 26.1.1 关于调度作业

调度作业又称定时任务，顾名思义，定时任务就是在特定的时间或符合某种时间规律自动触发并执行任务。

<img src={useBaseUrl("img/scdr.png")} />

## 26.1.2 快速入门

1. 定义作业处理程序 `MyJob`：

```cs showLineNumbers {1,9}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.CompletedTask;
    }
}
```

2. 在 `Startup.cs` 注册 `Schedule` 服务：

```cs showLineNumbers {1,3-4}
services.AddSchedule(options =>
{
    // 注册作业，并配置作业触发器
    options.AddJob<MyJob>(Triggers.Secondly()); // 表示每秒执行
});
```

3. 查看作业执行结果

```bash showLineNumbers {2,4,6,8,10,12}
info: 2022-11-17 16:23:56.0166669 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger1 2022/11/17 16:23:56  * * * * * *
info: 2022-11-17 16:23:57.0125960 +08:00 星期四 L MyJob[0] #17
      job1 job1_trigger1 2022/11/17 16:23:57  * * * * * *
info: 2022-11-17 16:23:58.0120379 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger1 2022/11/17 16:23:58  * * * * * *
info: 2022-11-17 16:23:59.0071986 +08:00 星期四 L MyJob[0] #5
      job1 job1_trigger1 2022/11/17 16:23:59  * * * * * *
info: 2022-11-17 16:24:00.0196813 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger1 2022/11/17 16:24:00  * * * * * *
info: 2022-11-17 16:24:01.0305799 +08:00 星期四 L MyJob[0] #17
      job1 job1_trigger1 2022/11/17 16:24:01  * * * * * *
```

### 26.1.2.1 指定作业 `Id`

默认情况下，不指定作业 `Id` 会自动生成 `job[编号]`。

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>("myjob", Triggers.Secondly());
});
```

查看作业执行结果：

```bash showLineNumbers  {2,4,6,8,10,12}
info: 2022-11-17 16:25:44.0339177 +08:00 星期四 L MyJob[0] #3
      myjob myjob_trigger1 2022/11/17 16:25:44  * * * * * *
info: 2022-11-17 16:25:45.0064838 +08:00 星期四 L MyJob[0] #14
      myjob myjob_trigger1 2022/11/17 16:25:45  * * * * * *
info: 2022-11-17 16:25:46.0186243 +08:00 星期四 L MyJob[0] #15
      myjob myjob_trigger1 2022/11/17 16:25:46  * * * * * *
info: 2022-11-17 16:25:47.0175115 +08:00 星期四 L MyJob[0] #16
      myjob myjob_trigger1 2022/11/17 16:25:47  * * * * * *
info: 2022-11-17 16:25:48.0304982 +08:00 星期四 L MyJob[0] #15
      myjob myjob_trigger1 2022/11/17 16:25:48  * * * * * *
info: 2022-11-17 16:25:49.0070855 +08:00 星期四 L MyJob[0] #16
      myjob myjob_trigger1 2022/11/17 16:25:49  * * * * * *
```

### 26.1.2.2 多个作业触发器

有时候，一个作业支持多种触发时间，比如 `每分钟` 执行一次，每 `5秒` 执行一次，每分钟第 `3/7/8秒` 执行一次。

```cs showLineNumbers {3-5}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(Triggers.Minutely()   // 每分钟开始
     , Triggers.Period(5000)   // 每 5 秒，也可以使用 Triggers.PeriodSeconds(5)
     , Triggers.Cron("3,7,8 * * * * ?", CronStringFormat.WithSeconds));  // 每分钟第 3/7/8 秒
});
```

查看作业执行结果：

```cs showLineNumbers {2,10,14,18,20}
info: 2022-11-17 16:45:40.5258191 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger2 2022/11/17 16:45:40  5000ms
info: 2022-11-17 16:45:45.5281473 +08:00 星期四 L MyJob[0] #3
      job1 job1_trigger2 2022/11/17 16:45:45  5000ms
info: 2022-11-17 16:45:50.5378417 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger2 2022/11/17 16:45:50  5000ms
info: 2022-11-17 16:45:55.5436499 +08:00 星期四 L MyJob[0] #3
      job1 job1_trigger2 2022/11/17 16:45:55  5000ms
info: 2022-11-17 16:46:00.0253985 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger1 2022/11/17 16:46:00  * * * * *
info: 2022-11-17 16:46:00.5494676 +08:00 星期四 L MyJob[0] #16
      job1 job1_trigger2 2022/11/17 16:46:00  5000ms
info: 2022-11-17 16:46:03.0238143 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger3 2022/11/17 16:46:03  3,7,8 * * * * ?
info: 2022-11-17 16:46:05.5629293 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger2 2022/11/17 16:46:05  5000ms
info: 2022-11-17 16:46:07.0169836 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger3 2022/11/17 16:46:07  3,7,8 * * * * ?
info: 2022-11-17 16:46:08.0128756 +08:00 星期四 L MyJob[0] #14
      job1 job1_trigger3 2022/11/17 16:46:08  3,7,8 * * * * ?
info: 2022-11-17 16:46:10.5731138 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger2 2022/11/17 16:46:10  5000ms
info: 2022-11-17 16:46:15.5841547 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger2 2022/11/17 16:46:15  5000ms
info: 2022-11-17 16:46:20.5866898 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger2 2022/11/17 16:46:20  5000ms
```

### 26.1.2.3 `串行` 执行

默认情况下，作业采用 `并行` 执行方式，也就是不会等待上一次作业执行完成，只要触发时间到了就自动执行，但一些情况下，我们可能希望等待上一次作业完成再执行，如：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(concurrent: false, Triggers.Secondly()); // 串行，每秒执行
});
```

```cs showLineNumbers {12}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
        await Task.Delay(2000, stoppingToken); // 这里模拟耗时操作，比如耗时2秒
    }
}
```

查看作业执行结果：

```cs showLineNumbers {2,8,14,20}
info: 2022-11-17 16:57:49.0898900 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger1 2022/11/17 16:57:49  * * * * * *
warn: 2022-11-17 16:57:50.0322409 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:50: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
warn: 2022-11-17 16:57:51.0099629 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:51: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
info: 2022-11-17 16:57:52.0192847 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger1 2022/11/17 16:57:52  * * * * * *
warn: 2022-11-17 16:57:53.0159256 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:53: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
warn: 2022-11-17 16:57:54.0101172 +08:00 星期四 L System.Logging.ScheduleService[0] #8
      11/17/2022 16:57:54: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
info: 2022-11-17 16:57:55.0038536 +08:00 星期四 L MyJob[0] #13
      job1 job1_trigger1 2022/11/17 16:57:55  * * * * * *
warn: 2022-11-17 16:57:56.0158085 +08:00 星期四 L System.Logging.ScheduleService[0] #16
      11/17/2022 16:57:56: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
warn: 2022-11-17 16:57:57.0276842 +08:00 星期四 L System.Logging.ScheduleService[0] #16
      11/17/2022 16:57:57: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
info: 2022-11-17 16:57:58.0100972 +08:00 星期四 L MyJob[0] #13
      job1 job1_trigger1 2022/11/17 16:57:58  * * * * * *
warn: 2022-11-17 16:57:59.0149137 +08:00 星期四 L System.Logging.ScheduleService[0] #13
      11/17/2022 16:57:59: The <job1_trigger1> trigger of job <job1> failed to execute as scheduled due to blocking.
```

默认情况下，使用 `串行` 执行但因为耗时导致**触发时间到了但实际未能执行**会默认输出 `warn` 警告日志，如需关闭只需要：

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.LogEnabled = false;
    options.AddJob<MyJob>(concurrent: false, Triggers.Secondly()); // 每秒执行
});
```

查看作业执行结果：

```bash showLineNumbers {2,4,6,8,10}
info: 2022-11-17 17:02:28.0559602 +08:00 星期四 L MyJob[0] #5
      job1 job1_trigger1 2022/11/17 17:02:28  * * * * * *
info: 2022-11-17 17:02:31.0183238 +08:00 星期四 L MyJob[0] #8
      job1 job1_trigger1 2022/11/17 17:02:31  * * * * * *
info: 2022-11-17 17:02:34.0130555 +08:00 星期四 L MyJob[0] #13
      job1 job1_trigger1 2022/11/17 17:02:34  * * * * * *
info: 2022-11-17 17:02:37.0040306 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger1 2022/11/17 17:02:37  * * * * * *
info: 2022-11-17 17:02:39.0142346 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger1 2022/11/17 17:02:39  * * * * * *
```

### 26.1.2.4 打印作业完整信息

框架提供了四种方式打印作业完整信息。

- **第一种：输出完整的作业 `JSON` 信息：`context.ConvertToJSON()`**

```cs showLineNumbers {11}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation(context.ConvertToJSON());
        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```json showLineNumbers {3,14}
info: 2022-11-17 17:13:41.0480946 +08:00 星期四 L MyJob[0] #5
      {
        "jobDetail": {
        "jobId": "job1",
        "groupName": null,
        "jobType": "MyJob",
        "assemblyName": "ConsoleApp32",
        "description": null,
        "concurrent": false,
        "includeAnnotations": false,
        "properties": "{}",
        "updatedTime": "2022-11-17T17:13:41.0247430+08:00"
      },
        "trigger": {
        "triggerId": "job1_trigger1",
        "jobId": "job1",
        "triggerType": "Furion.Schedule.CronTrigger",
        "assemblyName": "Furion",
        "args": "[\"@secondly\",0]",
        "description": null,
        "status": 2,
        "startTime": null,
        "endTime": null,
        "lastRunTime": "2022-11-17T17:13:41.0000000",
        "nextRunTime": "2022-11-17T17:13:42.0000000",
        "numberOfRuns": 1,
        "maxNumberOfRuns": 0,
        "numberOfErrors": 0,
        "maxNumberOfErrors": 0,
        "numRetries": 0,
        "retryTimeout": 1000,
        "startNow": true,
        "runOnStart": fals,
        "updatedTime": "2022-11-17T17:13:41.0250214+08:00"
      }
      }
```

- **第二种：输出单独的作业 `JSON` 信息：`jobDetail.ConvertToJSON()` 或 `trigger.ConvertToJSON()`**

```cs showLineNumbers {11-12,14-15}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;
        var trigger = context.Trigger;

        _logger.LogInformation(jobDetail.ConvertToJSON());
        _logger.LogInformation(trigger.ConvertToJSON(NamingConventions.UnderScoreCase));    // 支持三种属性名输出规则

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```json showLineNumbers {2-12,14-34}
info: 2022-11-17 17:17:15.0441407 +08:00 星期四 L MyJob[0] #3
      {
        "jobId": "job1",
        "groupName": null,
        "jobType": "MyJob",
        "assemblyName": "ConsoleApp32",
        "description": null,
        "concurrent": false,
        "includeAnnotations": false,
        "properties": "{}",
        "updatedTime": "2022-11-17T17:17:15.0103913+08:00"
      }
info: 2022-11-17 17:17:15.0503546 +08:00 星期四 L MyJob[0] #3
      {
        "trigger_id": "job1_trigger1",
        "job_id": "job1",
        "trigger_type": "Furion.Schedule.CronTrigger",
        "assembly_name": "Furion",
        "args": "[\"@secondly\",0]",
        "description": null,
        "status": 2,
        "start_time": null,
        "end_time": null,
        "last_run_time": "2022-11-17T17:17:15.0000000",
        "next_run_time": "2022-11-17T17:17:16.0000000",
        "number_of_runs": 1,
        "max_number_of_runs": 0,
        "number_of_errors": 0,
        "max_number_of_errors": 0,
        "num_retries": 0,
        "retry_timeout": 1000,
        "start_now": true,
        "run_on_start": false,
        "updated_time": "2022-11-17T17:17:15.0109612+08:00"
      }
```

- **第三种：输出单独的作业 `SQL` 信息：`jobDetail.ConvertToSQL()` 或 `trigger.ConvertToSQL()`**

```cs showLineNumbers {11-12,14-16}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;
        var trigger = context.Trigger;

        _logger.LogInformation(jobDetail.ConvertToSQL("作业信息表名", PersistenceBehavior.Appended));  // 输出新增语句
        _logger.LogInformation(trigger.ConvertToSQL("作业触发器表名", PersistenceBehavior.Removed, NamingConventions.Pascal));    // 输出删除语句
        _logger.LogInformation(trigger.ConvertToSQL("作业触发器表名", PersistenceBehavior.Updated, NamingConventions.UnderScoreCase));    // 输出更新语句

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```sql showLineNumbers {2,25,28}
info: 2022-11-17 17:35:11.1085426 +08:00 星期四 L MyJob[0] #9
      INSERT INTO 作业信息表名(
            [jobId],
            [groupName],
            [jobType],
            [assemblyName],
            [description],
            [concurrent],
            [includeAnnotations],
            [properties],
            [updatedTime]
      )
      VALUES(
            'job1',
            NULL,
            'MyJob',
            'ConsoleApp32',
            NULL,
            0,
            0,
            '{}',
            '2022/11/17 17:35:11'
      );
info: 2022-11-17 17:35:11.1150444 +08:00 星期四 L MyJob[0] #9
      DELETE FROM 作业触发器表名
      WHERE [TriggerId] = 'job1_trigger1' AND [JobId] = 'job1';
info: 2022-11-17 17:35:11.1190961 +08:00 星期四 L MyJob[0] #9
      UPDATE 作业触发器表名
      SET
            [trigger_id] = 'job1_trigger1',
            [job_id] = 'job1',
            [trigger_type] = 'Furion.Schedule.CronTrigger',
            [assembly_name] = 'Furion',
            [args] = '["@secondly",0]',
            [description] = NULL,
            [status] = 2,
            [start_time] = NULL,
            [end_time] = NULL,
            [last_run_time] = '2022/11/17 17:35:11',
            [next_run_time] = '2022/11/17 17:35:12',
            [number_of_runs] = 1,
            [max_number_of_runs] = 0,
            [number_of_errors] = 0,
            [max_number_of_errors] = 0,
            [num_retries] = 0,
            [retry_timeout] = 1000,
            [start_now] = 1,
            [run_on_start] = 0,
            [updated_time] = '2022/11/17 17:35:11'
      WHERE [trigger_id] = 'job1_trigger1' AND [job_id] = 'job1';
```

- **第四种：输出单独的作业 `Monitor` 信息：`jobDetail.ConvertToMonitor()` 或 `trigger.ConvertToMonitor()`**

```cs showLineNumbers {11-12,14-15}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;
        var trigger = context.Trigger;

        _logger.LogInformation(jobDetail.ConvertToMonitor());
        _logger.LogInformation(trigger.ConvertToMonitor());

        await Task.CompletedTask;
    }
}
```

查看作业打印结果：

```bash showLineNumbers {2,16}
info: 2022-11-17 17:39:09.1086517 +08:00 星期四 L MyJob[0] #3
      ┏━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
      ┣ MyJob
      ┣
      ┣ JobId：                     job1
      ┣ GroupName：
      ┣ JobType：                   MyJob
      ┣ AssemblyName：              ConsoleApp32
      ┣ Description：
      ┣ Concurrent：                False
      ┣ IncludeAnnotations：        False
      ┣ Properties：                {}
      ┣ UpdatedTime：               2022/11/17 17:39:09
      ┗━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
info: 2022-11-17 17:39:09.1133162 +08:00 星期四 L MyJob[0] #3
      ┏━━━━━━━━━━━  Trigger ━━━━━━━━━━━
      ┣ Furion.Schedule.CronTrigger
      ┣
      ┣ TriggerId：                job1_trigger1
      ┣ JobId：                    job1
      ┣ TriggerType：              Furion.Schedule.CronTrigger
      ┣ AssemblyName：             Furion
      ┣ Args：                     ["@secondly",0]
      ┣ Description：
      ┣ Status：                   Running
      ┣ StartTime：
      ┣ EndTime：
      ┣ LastRunTime：              2022/11/17 17:39:09
      ┣ NextRunTime：              2022/11/17 17:39:10
      ┣ NumberOfRuns：             1
      ┣ MaxNumberOfRuns：          0
      ┣ NumberOfErrors：           0
      ┣ MaxNumberOfErrors：        0
      ┣ NumRetries：               0
      ┣ RetryTimeout：             1000
      ┣ StartNow：                 True
      ┣ RunOnStart：               False
      ┣ UpdatedTime：              2022/11/17 17:39:09
      ┗━━━━━━━━━━━  Trigger ━━━━━━━━━━━
```

### 26.1.2.5 运行时（动态）操作作业

有时候，我们需要在运行时对作业动态的增加，更新，删除等操作，如动态添加作业：

1. 注册 `services.AddSchedule()` 服务

```cs showLineNumbers {2,5}
// 可以完全动态操作，只需要注册服务即可
services.AddSchedule();

// 也可以部分静态，部分动态注册
services.AddSchedule(options =>
{
    options.AddJob<MyJob>(concurrent: false, Triggers.PeriodSeconds(5));
});
```

2. 注入 `ISchedulerFactory` 服务

```cs showLineNumbers {4,11}
public class YourService: IYourService
{
    private readonly ISchedulerFactory _schedulerFactory;
    public YourService(ISchedulerFactory schedulerFactory)
    {
        _schedulerFactory = schedulerFactory;
    }

    public void AddJob()
    {
        _schedulerFactory.AddJob<MyJob>("动态作业 Id", Triggers.Secondly());
    }
}
```

3. 查看作业执行结果

```bash showLineNumbers {2,4,6,8,10,20}
warn: 2022-11-17 17:54:35.2654513 +08:00 星期四 L System.Logging.ScheduleService[0] #5
      Schedule Hosted Service cancels hibernation.
info: 2022-11-17 17:54:35.2670018 +08:00 星期四 L System.Logging.ScheduleService[0] #5
      The Scheduler of <动态作业 Id> successfully added to the schedule.
info: 2022-11-17 17:54:36.0834925 +08:00 星期四 L MyJob[0] #5
      job1 job1_trigger1 2022/11/17 17:54:36  5000ms
info: 2022-11-17 17:54:36.0911692 +08:00 星期四 L MyJob[0] #3
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:36  * * * * * *
info: 2022-11-17 17:54:37.0146251 +08:00 星期四 L MyJob[0] #18
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:37  * * * * * *
info: 2022-11-17 17:54:38.0071504 +08:00 星期四 L MyJob[0] #16
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:38  * * * * * *
info: 2022-11-17 17:54:39.0140840 +08:00 星期四 L MyJob[0] #17
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:39  * * * * * *
info: 2022-11-17 17:54:40.0173240 +08:00 星期四 L MyJob[0] #16
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:40  * * * * * *
info: 2022-11-17 17:54:41.0249043 +08:00 星期四 L MyJob[0] #16
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:41  * * * * * *
info: 2022-11-17 17:54:41.0550205 +08:00 星期四 L MyJob[0] #15
      job1 job1_trigger1 2022/11/17 17:54:41  5000ms
info: 2022-11-17 17:54:42.0171271 +08:00 星期四 L MyJob[0] #15
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:42  * * * * * *
info: 2022-11-17 17:54:43.0288486 +08:00 星期四 L MyJob[0] #18
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:43  * * * * * *
info: 2022-11-17 17:54:44.0092455 +08:00 星期四 L MyJob[0] #15
      动态作业 Id 动态作业 Id_trigger1 2022/11/17 17:54:44  * * * * * *
```

### 26.1.2.7 作业触发器特性

默认情况下，框架不会扫描 `IJob` 实现类的作业触发器特性，但可以设置作业的 `IncludeAnnotations` 进行启用。

1. 启用 `IncludeAnnotations` 扫描

```cs showLineNumbers {3}
services.AddSchedule(options =>
{
    options.AddJob(JobBuilder.Create<MyJob>().SetIncludeAnnotations(true)
        , Triggers.PeriodSeconds(5));
});
```

2. 在 `MyJob` 中添加多个作业触发器特性

```cs showLineNumbers {1-2}
[Minutely]
[Cron("3,7,8 * * * * ?", CronStringFormat.WithSeconds)]
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");

        await Task.CompletedTask;
    }
}
```

3. 查看作业执行结果

```bash showLineNumbers {2,4,6,8,10,12,14,16,18}
info: 2022-11-18 10:28:56.3382585 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger1 2022/11/18 10:28:56  5000ms
info: 2022-11-18 10:29:00.0219493 +08:00 星期五 L MyJob[0] #5
      job1 job1_trigger2 2022/11/18 10:29:00  * * * * *
info: 2022-11-18 10:29:01.3318716 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger1 2022/11/18 10:29:01  5000ms
info: 2022-11-18 10:29:03.0127992 +08:00 星期五 L MyJob[0] #16
      job1 job1_trigger3 2022/11/18 10:29:03  3,7,8 * * * * ?
info: 2022-11-18 10:29:06.3457728 +08:00 星期五 L MyJob[0] #16
      job1 job1_trigger1 2022/11/18 10:29:06  5000ms
info: 2022-11-18 10:29:07.0318919 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger3 2022/11/18 10:29:07  3,7,8 * * * * ?
info: 2022-11-18 10:29:08.0141479 +08:00 星期五 L MyJob[0] #8
      job1 job1_trigger3 2022/11/18 10:29:08  3,7,8 * * * * ?
info: 2022-11-18 10:29:11.3468100 +08:00 星期五 L MyJob[0] #16
      job1 job1_trigger1 2022/11/18 10:29:11  5000ms
info: 2022-11-18 10:29:16.3504029 +08:00 星期五 L MyJob[0] #14
      job1 job1_trigger1 2022/11/18 10:29:16  5000ms
```

## 26.1.3 作业信息 `JobDetail` 及构建器

### 26.1.3.1 关于作业信息

框架提供了 `JobDetail` 类型来描述作业信息，`JobDetail` 类型提供以下**只读属性**：

| 属性名               | 属性类型    | 默认值  | 说明                                                                 |
| -------------------- | ----------- | ------- | -------------------------------------------------------------------- |
| `JobId`              | `string`    |         | 作业 `Id`                                                            |
| `GroupName`          | `string`    |         | 作业组名称                                                           |
| `JobType`            | `string`    |         | 作业处理程序类型，存储的是类型的 `FullName`                          |
| `AssemblyName`       | `string`    |         | 作业处理程序类型所在程序集，存储的是程序集 `Name`                    |
| `Description`        | `string`    |         | 描述信息                                                             |
| `Concurrent`         | `bool`      | `true`  | 描述信息，如果设置为 `false`，那么使用 `串行` 执行                   |
| `IncludeAnnotations` | `bool`      | `false` | 是否扫描 `IJob` 实现类 `[Trigger]` 特性触发器                        |
| `Properties`         | `string`    | `"{}"`  | 作业信息额外数据，由 `Dictionary<string, object>` 序列化成字符串存储 |
| `UpdatedTime`        | `DateTime?` |         | 作业更新时间                                                         |

### 26.1.3.2 关于作业信息构建器

作业信息 `JobDetail` 是作业调度模块提供运行时的**只读类型**，那么我们该如何创建或变更 `JobDetail` 呢？

`JobBuilder` 是作业调度模块提供可用来生成运行时 `JobDetail` 的类型，这样做的好处可避免外部直接修改运行时 `JobDetail` 数据，还能实现任何修改动作监听，也能避免多线程抢占情况。

作业调度模块提供了多种方式用来创建 `JobBuilder` 对象。

1. **通过 `Create` 静态方法创建**

```cs showLineNumbers {2,5,8}
// 根据 IJob 实现类类型创建
var jobBuilder = JobBuilder.Create<MyJob>();

// 根据 Type 类型创建
var jobBuilder = JobBuilder.Create(typeof(MyJob));

// 根据程序集名称和类型完全限定名（FullName）创建
var jobBuilder = JobBuilder.Create("YourProject", "YourProject.MyJob");
```

2. **通过 `JobDetail` 类型创建**

这种方式常用于在运行时更新作业信息。

```cs showLineNumbers
var jobBuilder = JobBuilder.From(jobDetail);
```

3. **通过 `JSON` 字符串创建**

该方式非常灵活，可从配置文件，`JSON` 字符串，或其他能够返回 `JSON` 字符串的地方创建。

```cs showLineNumbers {2-12}
var jobBuilder = JobBuilder.From(@"
{
    ""jobId"": ""job1"",
    ""groupName"": null,
    ""jobType"": ""Furion.Application.MyJob"",
    ""assemblyName"": ""Furion.Application"",
    ""description"": null,
    ""concurrent"": true,
    ""includeAnnotations"": false,
    ""properties"": ""{}"",
    ""updatedTime"": ""2022-11-17T09:25:47.0471107+08:00""
}");
```

如果使用的是 `.NET7`，可使用 `"""` 避免转义，如：

```cs showLineNumbers {2-12}
var jobBuilder = JobBuilder.From("""
{
    "jobId": "job1",
    "groupName": null,
    "jobType": "Furion.Application.MyJob",
    "assemblyName": "Furion.Application",
    "description": null,
    "concurrent": true,
    "includeAnnotations": false,
    "properties": "{}",
    "updatedTime": "2022-11-17T09:25:47.0471107+08:00"
}""");
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 命名方式。

**不支持 `UnderScoreCase（下划线命名法）`** ，如 `"include_annotations": true`

:::

4. **还可以通过 `Clone` 静态方法从一个 `JobBuilder` 创建**

```cs showLineNumbers
var jobBuilder = JobBuilder.Clone(formJobBuilder);
```

:::important 克隆说明

克隆操作只会克隆 `AssemblyName`，`JobType`，`GroupName`，`Description`，`Concurrent`，`IncludeAnnotations`，`Properties`。

**不会克隆 `JobId`，`UpdatedTime`。**

:::

5. **还可以通过 `LoadFrom` 实例方法填充当前的 `JobBuilder`**

比如可以传递匿名类型，类类型：

```cs showLineNumbers {2,9,14}
// 会覆盖所有相同的值
jobBuilder.LoadFrom(new
{
      Description = "我是描述",
      Concurrent = false
});

// 支持多个填充，还可以配置跳过 null 值覆盖
jobBuilder.LoadFrom(new
{
      Description = "我是另外一个描述",
      Concurrent = false,
      IncludeAnnotations = default(object)      // 会跳过赋值
}, ignoreNullValue: true);
```

:::important 关于属性名匹配规则

支持 `CamelCase（驼峰命名法）`，`Pascal（帕斯卡命名法）` 和 `UnderScoreCase（下划线命名法）` 命名方式。

:::

### 26.1.3.3 设置作业信息构建器

`JobBuilder` 提供了和 `JobDetail` 完全匹配的 `Set[属性名]` 方法来配置作业信息各个属性，如：

```cs showLineNumbers {3,16}
services.AddSchedule(options =>
{
    var jobBuilder = JobBuilder.Create<MyJob>()
        .SetJobId("job1")   // 作业 Id
        .SetGroupName("group1") // 作业组名称
        .SetJobType("Furion.Application", "Furion.Application.MyJob") // 作业类型，支持多个重载
        .SetJobType<MyJob>()    // 作业类型，支持多个重载
        .SetJobType(typeof(MyJob))  // 作业类型，支持多个重载
        .SetDescription("这是一段描述")   // 作业描述
        .SetConcurrent(false)   // 并行还是串行方式，false 为 串行
        .SetIncludeAnnotations(true)    // 是否扫描 IJob 类型的触发器特性，true 为 扫描
        .SetProperties("{}")    // 作业额外数据 Dictionary<string, object> 类型序列化，支持多个重载
        .SetProperties(new Dictionary<string, object> { { "name", "Furion" } })  // 作业类型额外数据，支持多个重载，推荐！！！
        ;

    options.AddJob(jobBuilder, Triggers.PeriodSeconds(5));
});
```

### 26.1.3.4 作业信息/构建器额外数据

有时候我们需要在作业运行的时候添加一些额外数据，或者实现多个触发器共享数据，经常用于 `串行` 执行中，后面一个触发器需等待前一个触发器完成。

```cs showLineNumbers {13-14,16}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var jobDetail = context.JobDetail;

        var count = jobDetail.GetProperty<int>("count");
        jobDetail.AddOrUpdateProperty("count", count + 1);  // 递增 count

        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger} {count}");

        await Task.CompletedTask;
    }
}
```

查看作业运行日志：

```bash showLineNumbers {2,4,6,8,10}
info: 2022-11-18 16:48:35.8308170 +08:00 星期五 L ConsoleApp32.MyJob[0] #5
      job1 job1_trigger1 2022/11/18 16:48:35  5000ms 0
info: 2022-11-18 16:48:40.8437231 +08:00 星期五 L ConsoleApp32.MyJob[0] #8
      job1 job1_trigger1 2022/11/18 16:48:40  5000ms 1
info: 2022-11-18 16:48:45.8471287 +08:00 星期五 L ConsoleApp32.MyJob[0] #15
      job1 job1_trigger1 2022/11/18 16:48:45  5000ms 2
info: 2022-11-18 16:48:50.8607141 +08:00 星期五 L ConsoleApp32.MyJob[0] #15
      job1 job1_trigger1 2022/11/18 16:48:50  5000ms 3
info: 2022-11-18 16:48:55.8645520 +08:00 星期五 L ConsoleApp32.MyJob[0] #14
      job1 job1_trigger1 2022/11/18 16:48:55  5000ms 4
```

作业调度模块为 `JobDetail` 和 `JobBuilder` 提供了多个方法操作额外数据：

```cs showLineNumbers {2,5,8,11,14,17,20}
// 查看所有额外数据
var properties = jobDetail.GetProperties();

// 查看单个额外数据，返回 object
var value = jobBuilder.GetProperty("key");

// 查看单个额外数据泛型
var value = jobDetail.GetProperty<int>("key");

// 添加新的额外数据，支持链式操作，如果键已存在，则跳过
jobDetail.AddProperty("key", "Furion").AddProperty("key1", 2);

// 添加或更新额外数据，支持链式操作，不存在则新增，存在则替换，推荐
jobDetail.AddOrUpdateProperty("key", "Furion").AddOrUpdateProperty("key1", 2);

// 删除某个额外数据，支持链式操作，如果 key 不存在则跳过
jobDetail.RemoveProperty("key").RemoveProperty("key1");

// 清空所有额外数据
jobDetail.ClearProperties();
```

:::important 作业额外数据类型支持

作业额外数据每一项的值只支持 `int32`，`string`，`bool`，`null` 或它们组成的数组类型。

:::

### 26.1.3.5 多种格式字符串输出

`JobDetail` 和 `JobBuilder` 都提供了多种将自身转换成特定格式的字符串。

1. **转换成 `JSON` 字符串**

```cs showLineNumbers
var json = jobDetail.ConvertToJSON();
```

字符串打印如下：

```json showLineNumbers
{
  "jobId": "job1",
  "groupName": null,
  "jobType": "Furion.Application.MyJob",
  "assemblyName": "Furion.Application",
  "description": null,
  "concurrent": true,
  "includeAnnotations": false,
  "properties": "{}",
  "updatedTime": "2022-11-18T22:56:47.4149299+08:00"
}
```

2. **转换成 `SQL` 字符串**

```cs showLineNumbers {2,7,12}
// 输出新增 SQL，使用 CamelCase 属性命名
var insertSql = jobDetail.ConvertToSQL("tbName"
      , PersistenceBehavior.Appended
      , NamingConventions.CamelCase);

// 输出删除 SQL，使用 Pascal 属性命名
var deleteSql = jobDetail.ConvertToSQL("tbName"
      , PersistenceBehavior.Removed
      , NamingConventions.Pascal);

// 输出更新 SQL，使用 UnderScoreCase 属性命名
var updateSql = jobDetail.ConvertToSQL("tbName"
      , PersistenceBehavior.Updated
      , NamingConventions.UnderScoreCase);
```

字符串打印如下：

```sql showLineNumbers {2,26,30}
-- 新增语句
INSERT INTO tbName(
      [jobId],
      [groupName],
      [jobType],
      [assemblyName],
      [description],
      [concurrent],
      [includeAnnotations],
      [properties],
      [updatedTime]
)
VALUES(
      'job1',
      NULL,
      'ConsoleApp13.MyJob',
      'ConsoleApp13',
      NULL,
      1,
      0,
      '{}',
      '2022/11/18 23:16:18'
);

-- 删除语句
DELETE FROM tbName
WHERE [JobId] = 'job1';

-- 更新语句
UPDATE tbName
SET
      [job_id] = 'job1',
      [group_name] = NULL,
      [job_type] = 'ConsoleApp13.MyJob',
      [assembly_name] = 'ConsoleApp13',
      [description] = NULL,
      [concurrent] = 1,
      [include_annotations] = 0,
      [properties] = '{}',
      [updated_time] = '2022/11/18 23:16:18'
WHERE [job_id] = 'job1';
```

3. **转换成 `Monitor` 字符串**

```cs showLineNumbers
var monitor = jobDetail.ConvertToMonitor();
```

字符串打印如下：

```bash showLineNumbers
┏━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
┣ ConsoleApp13.MyJob
┣
┣ jobId：                     job1
┣ groupName：
┣ jobType：                   Furion.Application.MyJob
┣ assemblyName：              Furion.Application
┣ description：
┣ concurrent：                True
┣ includeAnnotations：        False
┣ properties：                {}
┣ updatedTime：               2022/11/18 23:26:47
┗━━━━━━━━━━━  JobDetail ━━━━━━━━━━━
```

## 26.1.4 作业处理程序 `IJob`

作业处理程序是作业具体执行的业务逻辑代码，通常由程序员编写，作业处理程序必须实现 `IJob` 接口。

### 26.1.4.1 如何定义

```cs showLineNumbers {1,3,5}
public class MyJob : IJob
{
    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        // your code...
    }
}
```

### 26.1.4.2 依赖注入

实现 `IJob` 的作业处理程序类型默认注册为 `单例`，**那么只要是单例的服务，皆可以通过构造函数注入**，如：`ILogger<>`，`IConfiguration`。

```cs showLineNumbers {3-4,6-7}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    private readonly IConfiguration _configuration;

    public MyJob(ILogger<MyJob> logger
        , IConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger} {count}");

        await Task.CompletedTask;
    }
}
```

- **如果是非单例的接口，如瞬时或范围服务，可通过 `IServiceProvder` 创建**

```cs showLineNumbers {5,9,18-19}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;
    private readonly IConfiguration _configuration;
    private readonly IServiceProvider _serviceProvider;

    public MyJob(ILogger<MyJob> logger
        , IConfiguration configuration
        , IServiceProvider serviceProvider)
    {
        _logger = logger;
        _configuration = configuration;
        _serviceProvider = serviceProvider;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        using var serviceScope = _serviceProvider.CreateScope();
        var repository = serviceScope.ServiceProvider.GetService<IRepository<User>>();

        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");

        await Task.CompletedTask;
    }
}
```

- **针对高频定时任务，比如每秒执行一次，或者更频繁的任务**

为了避免频繁创建作用域和销毁作用域，可创建长范围的作用域。

```cs showLineNumbers {1,5,13,18,25,27}
public class MyJob : IJob, IDisposable
{
    private readonly ILogger<MyJob> _logger;
    private readonly IConfiguration _configuration;
    private readonly IServiceScope _serviceScope;

    public MyJob(ILogger<MyJob> logger
        , IConfiguration configuration
        , IServiceProvider serviceProvider)
    {
        _logger = logger;
        _configuration = configuration;
        _serviceScope = serviceProvider.CreateScope();
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
        var repository = _serviceScope.ServiceProvider.GetService<IRepository<User>>();

        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");

        await Task.CompletedTask;
    }

    public void Dispose()
    {
        _serviceScope?.Dispose();
    }
}
```

### 26.1.4.3 `JobExecutingContext` 上下文

`JobExecutingContext` 上下文作为 `ExecuteAsync` 方法的第一个参数，提供了以下几个运行时信息：

- **`JobExecutingContext` 属性列表**
  - `JobId`：作业 `Id`
  - `TriggerId`：当前触发器 `Id`
  - `JobDetail`：作业信息
  - `Trigger`：作业触发器
  - `OccurrenceTime`：调度器检查时间，最准确的记录时间
  - `ExecutingTime`：实际执行时间（可能存在误差）
- **`JobExecutingContext` 方法列表**
  - `.ConvertToJSON(naming)`：将作业计划转换成 `JSON` 字符串

### 26.1.4.4 作业被取消处理

一下情况下，作业被临时暂停或取消，但作业处理程序还未处理完成，这个时候我们可以选择取消还是继续执行，如果选择同步取消：

```cs showLineNumbers {1,13,18}
public class MyJob : IJob
{
    private readonly ILogger<MyJob> _logger;

    public MyJob(ILogger<MyJob> logger)
    {
        _logger = logger;
    }

    public async Task ExecuteAsync(JobExecutingContext context, CancellationToken stoppingToken)
    {
       // 创建任务关联取消 Token
        var cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(stoppingToken);

        try
        {
            // 传递给异步服务
            await todo.SomeMethodAsync(cancellationTokenSource.Token);
        }
        catch (Exception ex)
        {
            // ...
        }

        _logger.LogInformation($"{context.JobId} {context.TriggerId} {context.OccurrenceTime} {context.Trigger}");
    }
}
```

这样当作业被取消时，`SomeMethodAsync` 也会同步取消。

## 26.1.5 作业触发器 `Trigger` 及构建器

### 26.1.5.1 关于作业触发器

框架提供了 `Trigger` 类型来描述作业具体的触发时间，`Trigger` 类型提供以下**只读属性**：

| 属性名              | 属性类型        | 默认值  | 说明                                                                 |
| ------------------- | --------------- | ------- | -------------------------------------------------------------------- |
| `TriggerId`         | `string`        |         | 作业触发器 `Id`                                                      |
| `JobId`             | `string`        |         | 作业 `Id`                                                            |
| `TriggerType`       | `string`        |         | 作业触发器类型，存储的是类型的 `FullName`                            |
| `AssemblyName`      | `string`        |         | 作业触发器类型所在程序集，存储的是程序集 `Name`                      |
| `Args`              | `string`        |         | 作业触发器参数，运行时将反序列化为 `object[]` 类型并作为构造函数参数 |
| `Description`       | `string`        |         | 描述信息                                                             |
| `Status`            | `TriggerStatus` | `Ready` | 作业触发器状态                                                       |
| `StartTime`         | `DateTime?`     |         | 起始时间                                                             |
| `EndTime`           | `DateTime?`     |         | 结束时间                                                             |
| `LastRunTime`       | `DateTime?`     |         | 最近运行时间                                                         |
| `NextRunTime`       | `DateTime?`     |         | 下一次运行时间                                                       |
| `NumberOfRuns`      | `long`          | `0`     | 触发次数                                                             |
| `MaxNumberOfRuns`   | `long`          | `0`     | 最大触发次数，`0`：不限制，`n`：N 次                                 |
| `NumberOfErrors`    | `long`          | `0`     | 出错次数                                                             |
| `MaxNumberOfErrors` | `long`          | `0`     | 最大出错次数，`0`：不限制，`n`：N 次                                 |
| `NumRetries`        | `int`           | `0`     | 重试次数                                                             |
| `RetryTimeout`      | `int`           | `1000`  | 重试间隔时间，毫秒单位                                               |
| `StartNow`          | `bool`          | `true`  | 是否立即启动                                                         |
| `RunOnStart`        | `bool`          | `false` | 是否启动时执行一次                                                   |
| `UpdatedTime`       | `DateTime?`     |         | 作业触发器更新时间                                                   |

### 26.1.5.2 作业触发器状态

作业触发器状态指示了当前作业触发器的状态，使用 `TriggerStatus` 枚举类型（`uint`），该类型包含以下枚举成员。

| 枚举名         | 枚举值 | 说明                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| `Backlog`      | `0`    | 积压，起始时间大于当前时间                                   |
| `Ready`        | `1`    | 就绪                                                         |
| `Running`      | `2`    | 正在运行                                                     |
| `Pause`        | `3`    | 暂停                                                         |
| `Blocked`      | `4`    | 阻塞，本该执行但是没有执行                                   |
| `ErrorToReady` | `5`    | 由失败进入就绪，运行错误当并未超出最大错误数，进入下一轮就绪 |
| `Archived`     | `6`    | 归档，结束时间小于当前时间                                   |
| `Panic`        | `7`    | 崩溃，错误次数超出了最大错误数                               |
| `Overrun`      | `8`    | 超限，运行次数超出了最大限制                                 |
| `Unoccupied`   | `9`    | 无触发时间，下一次执行时间为 `null`                          |
| `NotStart`     | `10`   | 未启动                                                       |
| `Unknown`      | `11`   | 未知作业触发器，作业触发器运行时类型为 `null`                |
| `Unhandled`    | `12`   | 未知作业处理程序，作业处理程序类型运行时类型为 `null`        |

### 26.1.5.3 关于作业触发器构建器

### 26.1.5.4 内置作业触发器

### 26.1.5.5 自定义作业触发器

### 26.1.5.6 设置作业触发器构建器

### 26.1.5.7 多种格式字符串输出

## 26.1.6 作业计划 `Scheduler` 及构建器

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.7 作业调度器 `ScheduleOptionsBuilder`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.8 作业计划工厂 `ISchedulerFactory`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.9 作业监视器 `IJobMonitor`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.10 作业执行器 `IJobExecutor`

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.11 作业持久化同步

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.12 作业集群控制

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.13 作业如何部署

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.14 常见问题

紧急编写中，将在 2022 年 11 月 21 日前完成，别催！

## 26.1.15 反馈与建议

:::note 与我们交流

给 Furion 提 [Issue](https://gitee.com/dotnetchina/Furion/issues/new?issue)。

:::
